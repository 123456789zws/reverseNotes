

 

# 发送手机验证码

【具体讲解见b站第一期视频】

## 抓包与参数分析

### 抓包

![1748245548518](assets/1748245548518.png)

https://api.weibo.cn/2/account/login_sendcode

post

### 请求头参数

![1748245641478](assets/1748245641478.png)

需要逆向X-sessionid



### 请求体

![1748245723458](assets/1748245723458.png)

这里面很明显aid需要逆向，标明设备信息

手机号是phone





## X-sessionid逆向



### 搜参数定位

![1748245853775](assets/1748245853775.png)

进去之后按 `X` 查交叉引用

![1748246149893](assets/1748246149893.png)

看着像uuid，

![1748246169753](assets/1748246169753.png)

果然是java自带的随机uuid，那我们也随便造一个



### 代码实现

![1748246284403](assets/1748246284403.png)



## aid逆向

### 搜参数定位

![1748246372543](assets/1748246372543.png)

注意大小写，第二个

点进去查找用例

等待的过程中，往下滑发现了aid

![1748246701080](assets/1748246701080.png)

暂时不表



key_aid查找用例非常多，![1748246729743](assets/1748246729743.png)

![1748246799315](assets/1748246799315.png)

put有点多，我们换成url定位，最后发现这个请求头参数是个LinkedHashMap，那我们回到这里，
随便找个LinkedHashMap定位，而且这个aid是挺长的，前面几个估计不是

我们找个类名看着顺眼的

![1748247381621](assets/1748247381621.png)

![1748247384200](assets/1748247384200.png)

这些参数和抓包的都很像，所以大概率是这里

![1748247431915](assets/1748247431915.png)

接下来找aid赋值

![1748247452626](assets/1748247452626.png)

![1748247461904](assets/1748247461904.png)

这是个三目运算符，直接找最后面那个

![1748247495511](assets/1748247495511.png)

神经。。。

看来没有进入这个函数

![1748247516803](assets/1748247516803.png)

所以是这里的aid

![1748247532201](assets/1748247532201.png)

这里很明显是xml取值

我们继续搜

![1748247562386](assets/1748247562386.png)

正好发现了我们前面提到的地方

![1748247581948](assets/1748247581948.png)



继续定位

![1748247669542](assets/1748247669542.png)

看这个代码是，传入str然后解析成json，从json中取出aid

我们要去定位str来源

![1748247728254](assets/1748247728254.png)

![1748247745343](assets/1748247745343.png)

这里读一下代码，看名字是发送了个post请求拿回来的

我们清空存储信息，抓包找一下

![1748247897816](assets/1748247897816.png)

稍微过滤一下，看url像是第二个，也正好是post

![1748247936118](assets/1748247936118.png)

请求头啥也没有

![1748247955723](assets/1748247955723.png)

请求体很明显data参数可能需要逆向

![1748247985440](assets/1748247985440.png)

看一下响应体，发现有aid，那么现在需要做的就是去逆向data参数

在此之前我们多次清空存储，看一下data变不变（虽然大概率变化

![1748248106485](assets/1748248106485.png)

对比一下，变了，接下来就是逆向data



### 搜url定位

![1748246846759](assets/1748246846759.png)

![1748246857374](assets/1748246857374.png)

进去查找用例

![1748246915241](assets/1748246915241.png)

看这样子是个retrofit

![1748246934697](assets/1748246934697.png)

我们照这个函数调用的位置

![1748246950391](assets/1748246950391.png)

![1748247007242](assets/1748247007242.png)

点进去发现是new了个map，这个函数内部也没有put aid，所以new的时候就有了或者发送过程中加进去的；

尝试点击LinkedHashMap，点不了，那就说明是后者，至此，我们需要去找拦截器
在此之前我们继续刚刚的搜参数





### 逆向data

![1748248155504](assets/1748248155504.png)

点进去交叉应用没搜到，可能反编译问题，我们搜LOGIN_URL

![1748248218883](assets/1748248218883.png)

![1748248232890](assets/1748248232890.png)

感觉不像是这里，问下ai这个函数在哪塞了data

![1748249385354](assets/1748249385354.png)

那说白了就是传入的str就是请求体

![1748249437599](assets/1748249437599.png)

```java
riseWind()得到请求体
```

![1748249494808](assets/1748249494808.png)

说明在so中

### 定位到so

找这个类的static

![1748249523778](assets/1748249523778.png)

说明是libsharewind.so

![1748249563283](assets/1748249563283.png)

ida打开

![1748249615800](assets/1748249615800.png)

就这个几个函数，点进去

把jni结构转一下

![1748249678851](assets/1748249678851.png)

alt+t找return

![1748249703262](assets/1748249703262.png)

很明显v16

![1748249717717](assets/1748249717717.png)

v16->v17

![1748249753646](assets/1748249753646.png)

v17这个sub_1c18得到的

点进去找return

![1748249815486](assets/1748249815486.png)

![1748249823648](assets/1748249823648.png)

看这样子就是v18作为指针了

![1748249847658](assets/1748249847658.png)

这里很明显发现了

![1748249871120](assets/1748249871120.png)

对比抓包，就是这3个参数

`sub_5BE0()`像是初始化

`sub_5DF8` 像是一个格式化字符串的函数，我们对应位置，那就是v15了

![1748249948104](assets/1748249948104.png)

这个v15是函数生成的

![1748249996050](assets/1748249996050.png)

![1748249998448](assets/1748249998448.png)

问下ai在干嘛

![1748250099150](assets/1748250099150.png)

既然是编码，结合抓包，那应该就是base64了，我们base64解码看一下

![1748250225966](assets/1748250225966.png)

解不出来，说明有点额外操作

![1748250265490](assets/1748250265490.png)

我们回头看还没编码，定位v16

![1748250292301](assets/1748250292301.png)

先是初始化，然后经过这个函数返回

![1748250334498](assets/1748250334498.png)

看到这个函数有点眼熟，问下ai这个函数在干嘛，问了下果然是base64，

![1748250422884](assets/1748250422884.png)

> 下次看见aAbcdef这种就代表和base64有关

那么关键参数就是a1了，就是调用时的p

![1748250463323](assets/1748250463323.png)

这个函数看着怪怪的

回到最外层函数

![1748250548538](assets/1748250548538.png)

这里看样子v27倒着来时传入的参数

![1748250576970](assets/1748250576970.png)

没啥有用信息，继续刚刚那个看着怪怪的函数继续

![1748250630196](assets/1748250630196.png)

![1748250651869](assets/1748250651869.png)

先分配v4内存，然后插入数据，这个sub_函数像是某种加密，传入了两个16字节字符串，最后又来个长度，非常像是aes

![1748250742054](assets/1748250742054.png)

问了ai，说是前面在进行填充；

![1748250856045](assets/1748250856045.png)

问了下，说白了就是个加密，我们直接改名为aes，顺便把另一个改成b64

![1748250960842](assets/1748250960842.png)

那就追踪v19

![1748251006080](assets/1748251006080.png)

先是5be0初始化，我们改成str_init

然后也是5df8这个函数进行格式化，我们直接改成str_format

![1748251112127](assets/1748251112127.png)

我们下载需要知道传入参数

所以可以去hookjava层传入的参数

![1748251183678](assets/1748251183678.png)

![1748251248137](assets/1748251248137.png)

看样子这个函数就是在加密最后把字符串转为urlencode形式

![1748251385966](assets/1748251385966.png)

多抓包几次

![1748251487016](assets/1748251487016.png)

对比一下，没啥变化



理一理整体流程：data是由 一个json字符串，再进行aes加密，再进行base64编码

我们取出抓包的data，对其进行反操作



### 逆向data加密算法

![1748259207704](assets/1748259207704.png)

至此我们已经知道如何生成data了



### 还原data

![1748260001872](assets/1748260001872.png)



### 还原aid

![1748260065160](assets/1748260065160.png)





### 效果图

![1748260077132](assets/1748260077132.png)



## 接口逆向还原

![1748268751418](assets/1748268751418.png)







# 手机验证码登录

【具体讲解见b站第一期视频】

## 抓包与参数分析

过滤login就行

![1748245985077](assets/1748245985077.png)

url是https://api.weibo.cn/2/account/login， post

![1748246008543](assets/1748246008543.png)

请求头没啥特殊的，x-sessionid前面已经逆向了

![1748246061042](assets/1748246061042.png)

请求体主要就是手机号和验证码，其次就是aid，前面也逆向了

## 代码实现

![1748268402429](assets/1748268402429.png)

## 效果图

![1748268372700](assets/1748268372700.png)



# 手机密码登录

【具体讲解见b站第二期视频】

## 抓包与参数分析

![1748333554242](assets/1748333554242.png)

s参数去看ck号登录那里

## 密码加密逆向

![1748335141059](assets/1748335141059.png)

这里函数名我手动改了，这里随便点一个进去就行

![1748335196222](assets/1748335196222.png)

参数是传进来的，继续找

![1748335242185](assets/1748335242185.png)

![1748335258889](assets/1748335258889.png)

hook一下传入参数

![1748335385209](assets/1748335385209.png)

## 定位so



![1748335408926](assets/1748335408926.png)

![1748335526133](assets/1748335526133.png)

定位java

![1748335672413](assets/1748335672413.png)



![1748335855612](assets/1748335855612.png)

密钥用hook的就行

![1748335915826](assets/1748335915826.png)

最后b64一下，和抓包的差不多，

注意：pkcs1.5填充具有随机性会导致每次加密数据不一样，最后进行发包测试验证就行





## 效果图

![1748333638258](assets/1748333638258.png)



# ck号登录

啥是ck号：使用cookie信息登录，后续可以模拟发送其他请求

微博ck格式如下：uid----gsid

例如![1748268669333](assets/1748268669333.png)



## 抓包与参数分析

- 先正常手机号验证码登录
- 再退出软件，重新进入

重新进入的过程中，微博会拿已经登录的信息进行登录，我们需要抓到这个包

![1748268866136](assets/1748268866136.png)



### 请求头

![1748268907436](assets/1748268907436.png)

没啥需要的



### 请求体

![1748268980327](assets/1748268980327.png)



## 获取ck信息：uid&gsid

我们的ck信息可以从手机号登录拿到，登录成功后或返回uid和gsid





## aid

我们需要把gsid和aid进行绑定，否则后续在进行转发帖子的过程中是没法转发成功

这里最好是伪装设备信息获取aid，并且把aid和ck信息写入文件中保存好，下次直接拿来用，这样能伪装成正常用户

而aid的逆向在前面的逆向过程中已经完成了



## s参数逆向

![1748325232110](assets/1748325232110.png)

### 定位java层

![1748269239299](assets/1748269239299.png)

![1748269257653](assets/1748269257653.png)

根据类名，找最可疑的，发现都很可疑，

我们换个办法，搜gsid参数

![1748269356379](assets/1748269356379.png)

发现是个retrofit接口，很可疑

![1748269388816](assets/1748269388816.png)

我们去找在哪调用了这个函数

![1748269410805](assets/1748269410805.png)

![1748269436515](assets/1748269436515.png)

![1748269459527](assets/1748269459527.png)

找赋值位置

![1748269478747](assets/1748269478747.png)

找引用位置

![1748269551045](assets/1748269551045.png)

随便找一个可疑的，就第一个了

![1748269580638](assets/1748269580638.png)

![1748269625827](assets/1748269625827.png)

位置挺多的，我们需要hook确认走了哪里

获取包名

```bash
frida-ps -Ua
> com.weico.international
```

启动frida

```bash
adb shell
su
./data/local/tmp/sfr16_2_1
```

编写hook脚本

![1748270096827](assets/1748270096827.png)

执行hook脚本

```bash
frida -U -f com.weico.international -l examples/hook确认s位置.js
```

![1748270076468](assets/1748270076468.png)

与抓包对比 

![1748270147267](assets/1748270147267.png)

str=7479401687, str2=1299295010, str3=weicoabroad

![1748270268498](assets/1748270268498.png)

这里就直接查看generateS

![1748270302029](assets/1748270302029.png)

![1748270329491](assets/1748270329491.png)

这个看不太懂，问一下ai【uniffi是用rust开发的so，而用c开发so是比较常见的】

![1748270475604](assets/1748270475604.png)

那么我们直接问lift函数是干嘛的

![1748270612738](assets/1748270612738.png)

说白了就是rust的字符串不能直接用，要转为java的字符串

![1748270669314](assets/1748270669314.png)

关键的就是箭头内的函数

![1748270691722](assets/1748270691722.png)

点进去发现是这样

发现没有具体实现，也不是native方法，这就是在so中实现的（我们可以问ai这个函数怎么没有具体实现）

![1748270827626](assets/1748270827626.png)

![1748270903410](assets/1748270903410.png)



### 定位so文件

我们定位so文件

首先是没找到system.loadlibrary

说明是在其他地方导入的或者是动态注册的

- 我们根据命名规则简单过滤一下

![1748271608838](assets/1748271608838.png)

![1748271737604](assets/1748271737604.png)

这样可以定位到libweico.so，我们也可以暴力扫描，实在不行hook查看

- 我们直接用工具扫描函数

![1748271641275](assets/1748271641275.png)

我们把so全部找出来，nm如果用bash是自带的，我这边用了git携带的bash

![1748272183542](assets/1748272183542.png)

看这样子是在libweico.so

写个sh脚本来扫描

```bash
#!/bin/bash
# 保存为 find_so.sh，在解压后的 lib 目录运行

TARGET_FUNC="uniffi_weico_fn_method_wsecurity_generate_s"

for so in *.so; do
    if nm -D "$so" 2>/dev/null | grep -q "$TARGET_FUNC"; then
        echo -n "扫描文件: $so ... "
        echo "✅ 命中目标函数"
        exit 0
    fi
done

echo "⚠️ 未在任何 .so 文件中找到目标函数"
exit 1
```



![1748272619555](assets/1748272619555.png)





- 我们也可以直接hook安卓底层，每次加载一个so文件就把其内部的函数名打印，如果存在相同的函数就打印so名



### 定位到so

![1748272842313](assets/1748272842313.png)

点进去，直接把代丢给ai解释

因为so代码调用太复杂了，我们不进行动态调试没法进行分析

![1748274128737](assets/1748274128737.png)



![1748274149850](assets/1748274149850.png)



![1748274174891](assets/1748274174891.png)



![1748275004063](assets/1748275004063.png)

问一下怎么传参的

![1748275364161](assets/1748275364161.png)



看不懂，so层由于是rust写的，反编译出来完全没法读

网上查资料寻找s参数，发现其他版本的微博也有s参数，我们去尝试其他版本的微博，

比如微博极速版



### 微博极速版s参数逆向

搜参数

![1748334393385](assets/1748334393385.png)

![1748334410175](assets/1748334410175.png)

![1748334461444](assets/1748334461444.png)

![1748334480017](assets/1748334480017.png)



去找libnative-lib.so

ida32打开

![1748334577169](assets/1748334577169.png)



![1748334612468](assets/1748334612468.png)

![1748334679923](assets/1748334679923.png)

我们这里可以判断一下是哪个

- 根据签名变化，我们传进来的参数是好几个，感觉aa4更可能，过程中也没发现拼接，所以就是aa4
- hook确认aa3 or aa4

![1748334780020](assets/1748334780020.png)

实际上是aa4

![1748334865868](assets/1748334865868.png)

直接把代码丢给ai让他还原

### 代码还原

![1748333849221](assets/1748333849221.png)

登录效果

![1748333879243](assets/1748333879243.png)

这里发包没问题代表s参数没算错，否则会报错

![1748333922152](assets/1748333922152.png)







# 点赞





# 转发



# 评论



