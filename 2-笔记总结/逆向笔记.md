本文包含很多网上已有内容，有些是复制粘贴的，一般会注明来源；若存在看不懂的，请使用搜索引擎搜索，若还不懂可联系我；





# 逆向扫盲



什么是逆向？ 通俗来讲，逆向工程就是将机器才能够懂的机器代码（0101二进制代码）翻译成人能够读懂的代码（汇编、smali代码）。 

但实际情况往往是，我们只寻找关键的代码去翻译或仅了解其业务逻辑，因为要将所有的机器代码翻译出来，工作量是极其巨大的且繁琐的。



## 按照语言类型分类

逆向工程按照编程语言类别，可以分为:

- 解释型语言的逆向(如Android APP)
- 编译型语言的逆向(如C/C++、Objective-C)

`解释型语言`(如Java)的运行环境是JVM之类的虚拟机，其反编译的难度通常较低。以Java语言为例，编译器编译的结果通常是*.class*或者*.dex*文件，在没有做代码混淆的情况下，很容易反汇编出Java源码，分析出代码逻辑。而且混淆也只是将类、方法、变量名称替换成*a* *b* *c* *d*这种没有任何意义的名字，增加理解难度而已。



`编译型语言`(如C/C++，Objective-C等)最终编译出来的机器代码就比较复杂，因为其机器代码是跟CPU架构相关的，因此针对不同的CPU架构编译出来的二进制文件是不同的，反汇编得到的代码也会不一样。往往需要针对特定的CPU架构去解读汇编语言，才能正确的分析出结果出来，这就需要对不同架构CPU的寄存器、寻址方式等特性有所了解才行。另外二进制文件反汇编出来的函数、变量名通常是机器生成的无意义字符串，所以分析难度通常相较于解释型语言会更大一些。

> 因此，汇编对于逆向工程是基础；





## 常用分析手段

1. 静态分析

   将机器代码反汇编成方便人类理解的代码，如smali代码（Java）、汇编代码或汇编代码翻译的C语言伪代码等等，通过分析这些比较低级的编程语言的代码，找到程序的业务流程或参数的加密逻辑；

   

2. 动态调试分析

   通过断点调试手段，让程序单步执行进行分析。动态分析往往是在静态分析出一定的结果的基础上进行，找到合适的地方给代码打断点，即时地读取当前变量的值，来进一步分析程序的逻辑、获取程序关系数据。

   常用的是 hook技术 和 程序断点调试；

   

3. 网络流量分析（抓包分析）

   通过代理方式或者其他方式，截取程序与服务器通信的数据流量（抓包），来分析客户端和服务端的通信协议。

   

4. 合理**猜测**

   根据正向开发流程来进行合理猜测，**这是最常用也最有有效的**，但不一定是最准确的；

   想要提高猜测的准度，就得积累编程经验、了解程序设计模式、学会查框架使用说明、学习读开源代码等等；





## 加密参数逆向方法

1. 纯算：**基于源码还原加密逻辑**：直接分析并实现加密算法；

2. 黑盒：**补环境复制代码进行模拟**：搭建完整的运行环境，将原有加密代码移植到新环境中运行；

   例如：js逆向补浏览器环境；app逆向用unidbg补jni环境；

3. rpc：**远程调用**：通过远程调用的方式直接复用目标环境的加密逻辑。





## 关于App逆向

根据开发方式而导致逆向方式而有所不同

接下来我们先对开发方式进行分类，并给出常用逆向路线

### 原生开发 

Native App Development

**特点**：最高性能，最佳用户体验，完整设备功能访问
**适用**：高性能应用、游戏、复杂交互应用

| 操作系统 | 应用层语言                 | native层    | 开发工具                                | 包的管理                                  | 使用框架                                                     | 部署平台                      |
| :------- | :------------------------- | ----------- | :-------------------------------------- | :---------------------------------------- | :----------------------------------------------------------- | ----------------------------- |
| Android  | java<br />kotlin           | .so via JNI | Android Studio<br />adb<br />firebase   | maven<br />gradle                         | **Jetpack Compose(现代)** <br />Android SDK<br />Room<br />WorkManager | Google Play<br />其他应用商店 |
| Ios      | **swift**<br />objective-c | .dylib /.a  | xcode<br />Instruments <br />TestFlight | **Swift Package Manager**,<br />CocoaPods | UIKit<br />SwiftUI<br />Core Data<br />Core ML<br />ARKit    | App Store                     |

安卓逆向（大部分）：

- 用反编译工具 反编译 dex文件 去看java代码

  > jadx，jeb，gda
  >
  > 大部分是：dex -> smail -> java

- 用反编译工具 反编译 so文件看 native层代码

  > ida、

  





### 跨平台开发

Cross-Platform

一般都是使用开发框架来生成不同平台的代码

**特点**：一次编写多端运行

| 框架                     | 技术栈      | 渲染方式        | 代表应用             | 优势                 |
| :----------------------- | :---------- | :-------------- | :------------------- | :------------------- |
| **React Native**         | JS/TS+React | 原生组件桥接    | Facebook, Skype，ins | 热更新，丰富生态     |
| **Flutter**              | Dart        | Skia自绘引擎    | Google Pay           | 高性能，UI一致性     |
| **Xamarin**              | C#          | 原生绑定        | UPS, Alaska Air      | .NET生态集成         |
| **Kotlin Multiplatform** | Kotlin      | 共享逻辑+原生UI | Netflix, Philips     | 原生性能，无缝互操作 |

这里比较常见的有 flutter 开发的app；这里提一嘴，棋牌类游戏用lua脚本写加密逻辑，然后用cocos2dlua框架加载lua脚本；



我这里只给出 flutter 开发的app的逆向方法：

1. 拿到libapp.so，对其使用针对性工具如reflutter和blutter初步处理
2. 结合ida·分析代码





### h5开发

webview调试即可

但是有的好像有V8调用js进行加密，但是我还不知道怎么解决







# 密码学基础与py算法还原

密码学：cryptography【希腊语kryptós“隐藏的”，gráphein“书写”】

我编一句话：正向和底层了解的越多，对于逆向的帮助越大；关于计算机的上下层我们都要了解和学习，不一定要手搓，但一定要快速辨别出来；

## 密码学的发展

**这一节主要是从发展中 理解密码学算法的诞生与消失，学习密码学的思想，可以不看**



一般分为：传统密码学和现代密码学；

分界标志是：1949年香农（C.E.Shannon）发表的论文《保密系统的通信理论》；



在此之前几千年历史的传统密码阶段，密码主要采用**代换**（Substitution）和**置换**（Permutation）的方式来实现，仅是一种文字变换的艺术（创造性的方法）。

香农通过将信息理论引入到密码学中，为密码学奠定了坚实的理论基础，形成了科学的密码学体系。





传统密码一般可分为（1）古典密码（2）近代密码



### 传统密码

1. [密码学的前世今生](https://blog.csdn.net/apr15/article/details/125031352)
2. [古典密码之棋盘密码(ADFGVX,ADFGX,Polybius)](https://www.cnblogs.com/folio/p/18146847)

#### 古典密码

古典密码阶段从古代到19世纪末，长达上千年，主要采用代换及置换的方式，并通过手工或简单器械实现的。





（1）斯巴达棒（密码棒）【核心思想：置换移位】

公元前约700年，古希腊的斯巴达人使用一种叫做scytale的棍子（斯巴达棒）来传递加密信息。

加密：斯巴达人在scytale螺旋形地缠绕一条羊皮纸。发信人在缠绕的羊皮纸上横着写下信息，然后将羊皮纸取下，这样羊皮纸上就是一些无意义的字符排列。

解密：收件人要解密这条信息，只需将羊皮纸再次缠绕在相同直径的棍棒上，就可以读出信件的内容了。

斯巴达棒使用改变文本中字母的阅读顺序，即置换（换位）的方法达到加密的目的。

配图：

<img src="http://image.thepaper.cn/www/image/27/92/405.jpg" align="left" width="300">





范例文字："Help me I am under attack".【横着写&读】

==>"HENTEIDTLAEAPMRCMUAK"【取下来后，竖着读】



假设编码字符串为"HENTEIDTLAEAPMRCMUAK"

解密：使用相同木棒，再次缠绕，横着读即可；



> 解密核心原理：直径 -> **每一圈能显示的文字数量；**（也就是字符间隔）



破译：合理猜测两个字符间隔，比如这里的20字符【笔者自己思考得到，可能方法不是最优，未经验证】

- 可以猜测是5轮一循环

  `HENTEIDTLAEAPMRCMUAK -> H I E C E`，无明显意义，舍去； 



- 可以猜测是4轮一循环

  `HENTEIDTLAEAPMRCMUAK -> H E L P M` ，有明显意义；

```python
# 没有写输入输出合法性校验
def scytale_encrypt(plain_text: str, length: int) -> str:
    """密码棒加密: 这里的length的作用是key，含义是一轮循环的字符数"""
    plain_text = plain_text.replace(" ", "").upper()  # 去掉空格，全部大写
    print(plain_text)
    plain_lst = list(plain_text)
    res = ""
    idx = 0
    while len(res) != len(plain_text):
        if idx >= len(plain_text):  # 索引越界，循环回来
            idx = idx % len(plain_text)
        if plain_lst[idx] == "":  # 读过了就跳过
            idx += 1
            continue
        res += plain_lst[idx]
        plain_lst[idx] = ""
        idx += length
    return res


def scytale_decrypt(cipher_text: str, length: int) -> str:
    """密码棒解密"""
    plain_lst = ["" for _ in range(len(cipher_text))]
    idx = 0
    for item in cipher_text:
        plain_lst[idx] += item
        idx += length
        if idx >= len(cipher_text):
            idx = idx % len(cipher_text)

    return "".join(plain_lst)


if __name__ == '__main__':
    plain_text = "Help me I am under attackK"
    encrypt_text = scytale_encrypt(plain_text, 10)
    print(encrypt_text)
    decrypt_text = scytale_decrypt(encrypt_text, 10)
    print(decrypt_text)

```







（2）棋盘密码

公元前2世纪，希腊人Polybius设计了一种将字母编码成符号的方法，称为棋盘密码。

棋盘密码只加密字母，不区分大小写（部分棋盘还可加密数字），若输入其它字符则原样保留。



1. Polybius【核心思想：编码替换】

   Polybius发明，通过Polybius矩阵进行加密密文，该矩阵是一个5*5的网格，通过Polybius矩阵将每个字母转换成两个数字, 第一个数字是该字母的行数,第二个数字是该字母的列数。

   加密：A 分解为（1，1）；B分解为（1，2）
   
   解密：（1，1）对应A
   
   Polybius矩阵（包含字母26，则i和j同时用一个坐标表示，则为25=5x5）如下：
   
   | \    | 1    | 2    | 3    | 4    | 5    |
   | ---- | ---- | ---- | ---- | ---- | ---- |
   | 1    | A    | B    | C    | D    | E    |
   | 2    | F    | G    | H    | I/J  | K    |
   | 3    | L    | M    | N    | O    | P    |
   | 4    | Q    | R    | S    | T    | U    |
   | 5    | V    | W    | X    | Y    | Z    |
   
   假设发送明文信息“Hello”，找到H对应2行3列，则加密为23，e加密为15，以此类推，得到密文：23 15 31 31 34。
   
   > 实际应用中，方阵中的字母顺序会被打乱，然后分发给信息发送方和接收方，增加第三方破解难度。
   
   特点：
   
   - **明文只能是字母**；密文全部为数字；
   - 密文长度是明文的两倍，即偶数；
   - 明文字母I和J的密文编码相同，解密后需人工确认。
   
   ```python
   # 没有写输入输出合法性校验
   class Polybius:
       polybius_table_letter = "abcdefghiklmnopqrstuvwxyz"  # j和i统一为i
       polybius_table_number = [(idx // 5 + 1, idx % 5 + 1) for idx in range(len(polybius_table_letter))]
   
       @staticmethod
       def encrypt(plain_text: str) -> str:
           res = []
           plain_text = plain_text.lower().replace("j", "i").replace(" ","")
           for item in plain_text:
               idx = Polybius.polybius_table_letter.index(item)
               row, column = Polybius.polybius_table_number[idx]
               res.append(f"{row}{column}")
           return "".join(res)
   
       @staticmethod
       def decrypt(cipher_text: str) -> str:
           res = []
           cipher_text = cipher_text.replace(" ", "")
           for i in range(0, len(cipher_text), 2):
               item = cipher_text[i:i + 2]  # 两个两个读
               row, column = int(item[0]), int(item[1])
               idx = (row - 1) * 5 + column - 1
               res.append(Polybius.polybius_table_letter[idx])
           return "".join(res)
   
   
   if __name__ == '__main__':
       plain_text = "Hello"
       encrypt_text = Polybius.encrypt(plain_text) # 2315313134
       print(encrypt_text)
       print(Polybius.decrypt(encrypt_text)) # hello
   
   ```
   
   



2. ADFGX&ADFGVX【核心思想：编码替换+置换移位】

   1918年，第一次世界大战将要结束时，法军截获了一份德军电报，电文中的所有单词都由A、D、F、G、X五个字母拼成，因此被称为ADFGX密码。

   ADFGX密码是1918年3月由德军上校FritzNebel发明的，**是结合了Polybius方阵和置换密码的双重加密方案**。

   ADFGX密码之所以选择ADFGX这几个字母，是因为它们译成摩斯密码时不容易混淆，可以降低传输错误的机率。

   而ADFGVX的出现是为了解决ADFGX加密造成的密文数字太多，加入一个V之后方阵变成了6x6，则字母和数字全部可以囊括，并且ij也可以更好区分；

   ADFGX密码表（包含字母，这里使用5x5的Polybius方阵）如下：
   
   > 这里使用移位的码表，btalpdhozkqfvsnqfvsnmrewy
   
   |  \   |  A   |  D   |  F   |  G   |  X   |
   | :--: | :--: | :--: | :--: | :--: | :--: |
   |  A   |  b   |  t   |  a   |  l   |  p   |
   |  D   |  d   |  h   |  o   |  z   |  k   |
   |  F   |  q   |  f   |  v   |  s   |  n   |
   |  G   |  g   | i/j  |  c   |  u   |  x   |
   |  X   |  m   |  r   |  e   |  w   |  y   |
   
   假设加密密文 “Hello” ：
   
   1. 经过编码替换：DD XF AG AG DF。(hello)
   
   2. 使用**密钥进行移位**：DF AX FA FA FG；(opqqs，移了4位) 
   
      > 这里使用bye密钥

|  b   |  y   |  e   |
| :--: | :--: | :--: |
|  D   |  F   |  A   |
|  X   |  F   |  A   |
|  F   |  A   |  F   |
|  G   |      |      |

密钥有几个字母，就有多少列，然后将密文一行一行填入。

把密钥“bye”按字母顺序重排为“bey”，**因此，密码不能有重复的字母**,依照这个顺序将表格中的字母一列一列的抄写得到：DX FG AA FF FA，这就是最终密文。可见，由于增加了密钥，ADFGX棋盘的加密强度明显高于Polybius棋盘密码。
特点：







## 各大算法来源

### md系列



### sha系列



### des与3des



### aes



### rsa



### sm系列

这里补一下sm算法；

国密算法（中国商用密码算法）**既包含对称算法，也包含非对称算法**，它是一个完整的密码算法体系，涵盖了多种密码技术。

1. **对称密码算法：**
   - **SM1：** 分组密码算法（分组长度、密钥长度均为128位）。算法细节不公开，通过硬件加密芯片实现。**（对称）**
   - **SM4：** 分组密码算法（分组长度、密钥长度均为128位）。**算法公开**，广泛应用于数据加密、无线局域网等领域。是国密对称算法的代表。**（对称）**
   - **SM7：** 分组密码算法（分组长度128位），主要用于非接触式IC卡应用（如门禁卡、会员卡等）。算法不公开。**（对称）**
2. **非对称密码算法（公钥密码算法）：**
   - **SM2：** 基于椭圆曲线密码（ECC）的公钥密码算法。它集成了数字签名算法、密钥交换协议和公钥加密算法。是我国自主设计的ECC算法标准，效率高、安全性好，是国密非对称算法的核心代表，广泛应用于电子认证、数字签名、密钥协商等。**（非对称）**
   - **SM9：** 基于标识的密码（IBC）算法。用户的公钥由其唯一标识（如身份证号、邮箱、手机号等）通过系统参数直接生成，无需数字证书。支持数字签名、密钥交换、加密等功能。简化了密钥管理，特别适合物联网、云计算等场景。**（非对称）**
3. **密码杂凑算法（哈希算法）：**
   - **SM3：** 密码杂凑算法（哈希算法），输出长度为256位。类似于SHA-256。用于生成数字摘要、数据完整性校验、消息认证码、数字签名等。**（既非对称也非对称，属于单向散列函数）**
4. **其他：**
   - **ZUC（祖冲之序列密码算法）：** 流密码算法，主要用于移动通信（4G/5G）的机密性保护。**（对称）**









## 算法出现顺序与原因

















## 逆向常用编码

什么叫编码：其实就是查表替换（映射）





### url编码

什么是url？**U**niform **R**esource **L**ocator（先扫盲一下

**统一资源定位器**、**定位地址**、URL地址、统一资源定位符 俗称网页地址，简称**网址**，是[因特网](https://zh.wikipedia.org/wiki/因特网)上标准的资源的地址（Address）

> 如同在网络上的门牌

统一资源定位符的**完整**格式如下：

> \[协议类型\]://\[访问资源需要的凭证信息\]@\[服务器地址\]:\[端口号\]/\[资源层级UNIX文件路径文件名\]?\[查询\]#\[片段ID\]



案例

以 `https://zh.wikipedia.org:443/w/index.php?title=Special:随机页面`为例，其中：

1. **https**，是协议；
2. **zh.wikipedia.org**，是服务器；
3. **443**，是服务器上的网络端口号；
4. **/w/index.php**，是路径；
5. **?title=Special:随机页面**，是询问。

> 什么时候会有片段id？
>
> https://github.com/LunFengChen/reverseNotes/blob/master/xxx.js#L10
>
> 代表代码第10行，这种一般都是网站自己有一个规则

> 什么时候会有访问资源需要的凭证信息？
>
> 如果以某个代理访问的时候会用到！





使用浏览器进行Http网络请求时，若请求query中包含中文，中文会被编码为 `%+16进制+16进制`形式。【[文章来源](https://www.cnblogs.com/xiaxveliang/p/14438336.html)】

为什么要进行这种转义编码吗？编码的原理又是什么？

> **https://www.baidu.com/s?wd=你好** -> **https://www.baidu.com/s?wd=%E4%BD%A0%E5%A5%BD**

也叫**百分号编码（Percent Encoding）**

1. 为啥需要这么编码

   一些不在ascii编码表的以及**不安全的字符**（甚至易忽略的：空格），为这些字符设计一套编码表来转码

   The ASCII control characters %00-%1F were originally designed to control hardware devices.

   Control characters have nothing to do inside a URL.

   > 不在ascii的指的是 中文等其他语言的字符；
   >
   > 不安全的 如下
   >
   > | <    | >    | %    | }    | {    | \|   | \    |
   > | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   > | %3C  | %3E  | %25  | %7D  | %7B  | %7C  | %5C  |
   > | ^    | ~    | [    | ]    | `    | 空格 | #    |
   > | %5E  | %7E  | %5B  | %5D  | %60  | %20  | %23  |

2. 编码原理

   **将需要转码的字符，按指定编码方式（默认使用UTF-8编码）转化为字节流，每个字节按16进制表示，并添加%组成一个percent编码。**

   > `你好 -> E4 BD A0 E5 A5 BD（16进制字节流） -> %E4%BD%A0%E5%A5%BD` 

3. **空格编码注意事项**

   - `空格`编码为`+`的情况；[W3C标准](https://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1)
     提交表单时请求时`Content-Type：application/x-www-form-urlencoded`的情况下，URL请求查询字符串中出现`空格`时，需替换为`+`。
   - 其他情况`空格`编码为`%20`；[rfc3986标准](https://tools.ietf.org/html/rfc3986)

   > 有时我们从抓包软件复制的表单为 字典之后，**他的+和%20因为这个原因是不对的，需要额外注意！**

```python
from urllib import parse

def parse_urlencode(url_encoded_string: str) -> str:
    return parse.quote(url_encoded_string)


if __name__ == "__main__":
    print(parse_urlencode("你好")) # '%E4%BD%A0%E5%A5%BD'
```



### base64编码

####  初步扫盲

Base64是网络上最常见的传输8Bit字节代码的编码方式。

为啥会出现这个?

> 在参数传输的过程中经常遇到的一种情况：使用全英文的没问题，但一旦涉及到中文就会出现乱码情况。与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。
>
> Base64的出现就是为了解决此问题，**它是基于64个可打印的字符来表示二进制的数据的一种方法。**
>
> Base64在URL、Cookie、网页传输少量二进制文件中也有相应的使用。



#### 编码原理

1. 将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。

   > 为啥3个字节一组？
   >
   > 因为6和8的最小公倍数为24，三个字节正好24个二进制位，每6个bit位一组，恰好能够分为4组。
   >
   > 不足3位的怎么办：补0；

2. 将上面的24个二进制位每6个一组，再分为4组。

3. 在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。

   **因此，Base64编码之后的文本，要比原文大约三分之一。**

   > 所以在某些so中我们会看到初始化长度的时候会出现1/3相关的字眼；

4. 根据Base64编码对照表获得对应的值。0映射到->，61映射到9，62映射到+，63映射到/

   **标准编码表：`A-Za-z0-9+/ `**  **认准标准编码表**

   > 有些会只交换其中的a-z和A-Z，让你误以为是标准b64；
   >
   > 有的会交换+/
   >
   > 有些会直接打乱编码表；



不需要填充示例

| 文      本 | M        | a        | n        |
| ---------- | -------- | -------- | -------- |
| ASCII 编码 | 77       | 97       | 110      |
| 8bit  字节 | 01001101 | 01100001 | 01101110 |

| 6bit  字节 | 010011 | 010110 | 000101 | 101110 |
| ---------- | ------ | ------ | ------ | ------ |
| Base64索引 | 19     | 22     | 5      | 46     |
| Base64编码 | T      | W      | F      | u      |



需要填充示例

| 文      本 | M        |          |          |
| ---------- | -------- | -------- | -------- |
| ASCII 编码 | 77       |          |          |
| 8bit  字节 | 01001101 | 00000000 | 00000000 |

| 6bit  字节 | 010011 | 010000 | 000000 | 000000 |
| ---------- | ------ | ------ | ------ | ------ |
| Base64索引 | 19     | 16     |        |        |
| Base64编码 | T      | Q      | =      | =      |



#### python实现

```python
import random
import string

#  base 字符集： A-Za-z0-9+/
base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/'


def b64encode(origin_bytes: bytes) -> str:
    """
    base64编码
    :param origin_bytes: 原始bytes
    :return: base64编码后的字符串
    """
    # 1. 将bytes按照每一个转换为二进制字符串（每一个都是8位的）
    # base64_bytes = ['{:0>8}'.format(bin(byte)[2:]) for byte in origin_bytes] # 列表推导式写法
    base64_bytes = []
    for byte in origin_bytes:
        # b: byte，这里显示出来的是数字 77; bytes迭代出来在python中是int类型，其他语言可能会有byte类型
        # bin(b): 10进制数转换为2进制字符串
        temp: str = bin(byte)
        # >8：表示将字符串右对齐，总宽度为8字符； 0：不足8位时，用'0'在左侧填充。
        base64_bytes.append('{:0>8}'.format(temp[2:]))  # 去掉字符串前面的部分
    # 2. 将3个字节的二进制字符串，以每6比特，转换为4个整数
    resp = ''
    nums = len(base64_bytes) // 3
    integral_part = base64_bytes[0:3 * nums]
    while integral_part:
        # 总bit数不变，一次循环24bit：原本的3位一组，每组8bit；扩充到4位一组，也就是每组6bit。
        # 取三个字节，以每6比特，转换为4个整数
        cycle_part = ''.join(integral_part[0:3])
        tmp_unit = [int(cycle_part[x: x + 6], 2) for x in [0, 6, 12, 18]]  # 每6位一组，从2进制数转10进制整数
        # 取对应base64字符
        resp += ''.join([base64_charset[i] for i in tmp_unit])
        # 取后面的部分，继续循环
        integral_part = integral_part[3:]  # 剔除掉已经处理过的部分，取后面的部分继续循环

    # 不足3位的额外处理
    remain = len(base64_bytes) % 3  # 计算剩余字节数：0（不用补），1（补2个），2（补1个）
    if remain:
        # 取出还剩下的字节，计算需要补的字节数（3-remain），每个补0000 0000
        remain_part = ''.join(base64_bytes[3 * nums:])
        cycle_part = remain_part + '00000000' * (3 - remain)  # 每6位一组，转为整数+ (3 - remain) * '0' * 8
        # 注意尾部的[:remain+1]: 只取前面不为0的字节；
        tmp_unit = [int(cycle_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]
        resp += ''.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * '='  # 差几个字节就补几个=

    return resp


def b64decode(base64_str: str) -> bytes:
    """
    base64解码
    :param base64_str: base64编码字符串
    :return: 解码后的原始bytes
    """
    # 1. 移除末尾的等号填充符并记录填充数量
    pad_count = base64_str.count('=')
    clean_str = base64_str.rstrip('=')  # 去掉右侧的等号填充符

    # 2. 将每个Base64字符转换回6位二进制字符串
    bin_string = ''  # 最终的二进制字符串
    for char in clean_str:
        # 获取字符对应的在码表中的6位整数值
        index = base64_charset.index(char)
        # 将整数转换为6位二进制字符串（左侧补0）
        bin_string += f"{index:06b}"
    # 补尾部0
    bin_string += '0' * 6 * pad_count

    # 3. 将二进制字符串按8位一组转换为字节
    origin_bytes = []
    # 遍历二进制字符串，每8位一组
    for i in range(0, len(bin_string), 8):
        # 获取当前8位组（可能不足8位时用右侧补0）
        byte_str = bin_string[i:i + 8]
        # 将二进制字符串转换为整数（字节值）
        temp_int = int(byte_str, 2)
        if temp_int == 0:
            continue
        origin_bytes.append(temp_int)

    return bytes(origin_bytes)


if __name__ == '__main__':
    s = "".join(random.sample('abcdefghijklmnopqrstuvwxyz', random.randint(1, 26)))
    s_b64encode = b64encode(s.encode("utf8"))
    s_b64decode = b64decode(s_b64encode).decode("utf8")
    print(f'{s} -> {s_b64encode} -> {s_b64decode}')



```









#### 编码出现的一些现象

1. 长度现象

   > 由于我们可用字符只有64位，码表大小被压缩了，所以字符串长度或扩充；
   >
   > 而因为采取的是24的因子6和8，对应的是3和4，所以长度扩充1/3





#### 算法辨别

1. 经典码表：A-Za-z0-9+/

   - 字符串出现：大小写混搭，时不时出现数字；偶尔看见+/之类的；
   - 字符串出现少量=号

2. 码表长度64

   代码中：由于index从0开始所以会有63之类的，由于+/没有直接写入码表，所以可能有61；



#### 魔改思路

1. 简单微调码表

2. 打乱码表

3. 对编码后的字符串进行二次码表替换

   如+替换成%2B就是一种，我可以替换成 `-1` ；只要我自己能解析出来





## 摘要算法

### 算法特点

也就哈希函数；

特点：

1. 不同长度输入，产生固定长度输出

2. 散列后密文不可逆（无法推导明文

   > 如果没有传输明文，说明是固定的或者随机；

3. 散列结果唯一

什么时候用？

确保数据完整性，未被篡改；

1. 网络包的签名参数：将网络包中的其他参数进行加密得到签名，服务器使用同意算法进行计算与签名比对，异常则报错；





### md5

算法特点：固定128 bits，十六进制字符串32位，如果是16位（舍弃前、后8位）

@落叶 的[算法笔记](https://www.yuque.com/nanren-w8l2z/xgu63m/bfhqvc5d7cm0aw73?singleDoc#)

1. 填充到64字节

   - 先转字节

     `admin -> 61 64 6D 69 6E` 

   - 填到56字节：第一位填充 0x80，剩下的填充 00 ，直到达到 56 个字节； $56-5-1=50$ , 所以填充50个`00`      

     `61 64 6D 69 6E 80 00(50个)`

   - 填剩下8字节：第一位填充 `消息长度 * 8`，也就是 `5*8=40=0x28`，剩下的填充 `00`

     `61 64 6D 69 6E 80 0(50个) 28 00(7个)`

     

   - 注意事项

     1. 输入小于56个字节时 对其进行正常填充

     2. 输入等于56个字节时 直接填充长度

     3. 输入大于56小于64 首先填充80 后面的用0补 达到64字节后 再填充64字节

        `61 64 6D 69 6E ... 61(假设到这是57长度)`

        (1) `61 64 6D 69 6E ... 61(假设到这是57长度) 80 00(7次)`

        (2) `00(填充56次) 2 0 (填充7次) 共64字节`









## 对称加密

### 算法特点

加解密可逆；**加解密密钥相同**；



| 算法                            | 密钥长度                                             |
| ------------------------------- | ---------------------------------------------------- |
| rc4                             | 1-256字节                                            |
| des                             | 8字节                                                |
| 3des<br />desede<br />tripledes | 24字节                                               |
| aes                             | 16（AES128）<br />24（AES192）<br />**32（AES256）** |
| sm4                             |                                                      |





### des

[des文档](https://www.yuque.com/nanren-w8l2z/xgu63m/owxzxq7qn0b5o53x?singleDoc#)



### 3des





### aes

[aes文档](https://www.yuque.com/nanren-w8l2z/xgu63m/uoff9ovsmhqki9wh?singleDoc#)

1. ecb：只需要key

2. cbc：需要key和iv

   ```python
   from Crypto.Cipher import AES
   from Crypto.Util.Padding import pad, unpad
   
   
   def aes_encrypt(plain_text: bytes, aes_key: bytes, aes_iv: bytes) -> bytes:
       return AES.new(aes_key, AES.MODE_CBC, aes_iv).encrypt(pad(plain_text, AES.block_size))
   
   
   def aes_decrypt(cipher_text: bytes, aes_key: bytes, aes_iv: bytes) -> bytes:
       return unpad(AES.new(aes_key, AES.MODE_CBC, aes_iv).decrypt(cipher_text), AES.block_size)
   
   ```




### sm4





### rc2





### rc4



### rc5



### rc6





### Blowfish





### Rabbit





### 异或

















## 非对称加密

### rsa

1. 随机填充：pkcs#1
   ```bash
   pip install pycryptodome
   ```

   ```python
   from Crypto.Cipher import PKCS1_v1_5
   from Crypto import Random
   from Crypto.PublicKey import RSA
   import base64
   
   
   def rsa_ecb_encrypt(plain_bytes: bytes, public_key_b64: str) -> bytes:
       public_key_pem = base64.b64decode(public_key_b64)
       public_key = RSA.importKey(private_key_pem)
   
       cipher = PKCS1_v1_5.new(public_key)
       ciphertext = cipher.encrypt(plain_bytes)
   
       return ciphertext
   
   def rsa_ecb_decrypt(cipherd_bytes: bytes, private_key_b64: str) -> bytes:
       private_key_pem = base64.b64decode(private_key_b64)
       private_key = RSA.import_key(private_key_pem)
       cipher = PKCS1_v1_5.new(private_key)
       decrypted_bytes = cipher.decrypt(cipherd_bytes, Random.new().read(16))
       return decrypted_bytes
   
   # 加密案例
   public_key_b64 = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A"
   plain_hex = "6535353535333338343335323038356231613535373438333030623237346331"
   
   # 加密: 拿到明文bytes，公钥b64 -> 得到密文bytes
   plain_bytes = bytes.fromhex(plain_hex)
   res_bytes = rsa_ecb_encrypt(plain_bytes, public_key_b64)
   # 用b64编码打印
   res_b64 = base64.b64encode(res_bytes).decode("utf8")
   print(res_b64)
   
   # 解密案例
   cipherd_b64 = "gYMBWpwHYvLmMYshV/p/9u1vUhmyZS"
   private_key_b64 = "MIIEvwIBADANBgkqhkiG9w0BAQ"
   # 解密: 拿到密文bytes，私钥b64 -> 得到明文bytes
   cipherd_bytes = base64.b64decode(cipherd_b64)
   res_bytes = rsa_ecb_decrypt(cipher_bytes,key_b64)
   # 用字符串打印
   res_str = res_bytes.decode("utf8")
   print(res_str)
   ```

2. 固定填充

   ```python
   from Crypto.Util.number import bytes_to_long, long_to_bytes
   from Crypto.PublicKey import RSA
   import base64
   
   
   def rsa_fixed_encrypt(message_bytes: bytes, public_key_b64: str) -> str:
       """固定输出的RSA加密"""
       # 解码Base64公钥
       der_data = base64.b64decode(public_key_b64)
       key = RSA.import_key(der_data)
   
       # 明文转整数
       plain_int = bytes_to_long(message_bytes)
   
       # RSA核心运算：c = m^e mod n
       cipher_int = pow(plain_int, key.e, key.n)
   
       cipher_bytes = long_to_bytes(cipher_int) 
       return cipher_bytes
   
   
   # 加密案例
   public_key_b64 = "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A"
   plain_hex = "6535353535333338343335323038356231613535373438333030623237346331"
   
   # 加密: 拿到明文bytes，公钥b64 -> 得到密文bytes
   plain_bytes = bytes.fromhex(plain_hex)
   res_bytes = rsa_fixed_encrypt(plain_bytes, public_key_b64)
   # 用b64编码打印
   res_b64 = base64.b64encode(res_bytes).decode('utf-8')
   print(res_b64)
   ```

   





### sm2



# 逆向常用数据格式互转

提供js和py的脚本，一般发包或者还原算法都是用的这两，对于经典加密算法（在密码学基础）会使用c和py来实现 

## str & bytes or bytesArr

1. str2bytesArr

   **java端的字节数组是 有符号的**[-128, -127]，python和js的都是无符号的[0, 255] 

   > js端本质就是每个字符用utf8编码得到对应的数字，然后组合成字节数组；
   >
   > 解码的话也是一样，拿到数字，**去utf8编码表查表**，得到对应字符，然后组合起来；
   >
   > 对于这个查表，我们直接使用内置函数就行；对于b64的查表实现，我们在密码学基础会有c和py代码

   ```js
   function str2bytearray(str) {
      	// str -> bytearray
       const encoder = new TextEncoder('utf-8');
       return encoder.encode(str);
   }
   
   function bytearray2str(bytesArr) {
       // bytearray -> str
       const decoder = new TextDecoder('utf-8');
       return decoder.decode(bytesArr);
   }
   
   
   function main() {
       // 示例
       console.log(str2bytearray('加密数据')); // 输出: Uint8Array(12) [229, 138, 160, 229,175, 134, 230, 149, 176, 230, 141, 174]
       console.log(bytearray2str(new Uint8Array([229, 138, 160, 229, 175, 134, 230, 149, 176, 230, 141, 174]))); // 输出: 加密数据
   }
   
   main();
   
   ```

   

python

1. str2bytes

   > python端有两种选择：
   >
   > 一是每个字符转utf8编码后得到对应数字然后直接用16进制表示，组合成bytes形式的‘字符串’
   >
   > 二是转bytearray，本质其实还是先转bytes的

   ```python
   def str2bytes(s: str) -> bytes:
       # str -> bytes
       return s.encode("utf8")
   
   def bytes2str(s: bytes) -> str:
       # str -> bytes
       return s.decode("utf8")
   
   if __name__ == '__main__':
       # 示例
       text = "加密数据"
       bytes_result = str2bytes(text)
   	print(bytes_result) # b'\xe5\x8a\xa0\xe5\xaf\x86\xe6\x95\xb0\xe6\x8d\xae'
   ```

2. str2bytesArr

   但是实际上走的也是和上面一样的

   ```python
   def str2bytearray(s: str) -> bytearray:
       # str -> bytes -> bytearray
       return bytearray(s.encode("utf8"))
   
   def bytearray2str(ba: bytearray) -> str:
       return ba.decode("utf-8")
   
   if __name__ == '__main__':
       # 示例
       text = "加密数据"
       print(str2bytearray(text)) # bytearray(b'\xe5\x8a\xa0\xe5\xaf\x86\xe6\x95\xb0\xe6\x8d\xae')
       print(bytearray2str(bytearray([229, 138, 160, 229, 175, 134, 230, 149, 176, 230, 141, 174])))
   ```

   

## 有符号和无符号 bytearray

字节数转换成有符号字节数计算过程 (byte << 24) >> 24，转成无符号字节数计算过程 & 255。

**说白了就是把 `-128 ~ 127` 的数，与 `0-255` 区间的数进行互相映射**

1. 有符号转无符号

   ```python
   # 1. 掩码计算
   python_bytes = [i&0xff for i in [-118,70,-1]] # 0xff -> 255
   print(python_bytes) # [138, 70, 255])
         
   # 2. 移位（python的数类型浮动所以需要8字节掩码）
   python_bytes = [((b << 24) & 0xFFFFFFFF) >> 24 for b in [-118,70,-1]]
   print(python_bytes) # [138, 70, 255])
   
   # 3. 加法映射
   python_bytes = [i+256 if i<0 else i for i in [-118,70,-1]]
   print(python_bytes) # [138, 70, 255])
   
   ```

2. 无符号转有符号

   ```python
   # 1. 异或计算
   java_bytes = [(b ^ 0x80) - 0x80 for b in [138, 70, 255]]  # 0x80 -> 128
   print(java_bytes) # [-118, 70, -1]
   
   # 2. 减法映射
   java_bytes = [b if b < 128 else b - 256 for b in [138, 70, 255]]
   print(java_bytes) # [-118, 70, -1]
   ```

   

字节数组记得要转为bytes





## str & hex

我们可以把bytes理解成bytes的一种可见表现形式，主要应对于不处于可见字符表中的字符的可视化表示【ascii中的127】

用处很广：地址表示；内存数据表示；

> 这个一般都是需要bytes或者btyearray做桥梁的
>
> - js或者java要用字节数组桥梁
> - py使用bytes

```js
function str2hex(str) {
    // str -> bytearray -> hex
    const encoder = new TextEncoder();
    const bytes = encoder.encode(str);
    return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
}

function hex2str(hex) {
    const bytes = new Uint8Array(hex.length / 2);
    for (let i = 0; i < hex.length; i += 2) {
        bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    const decoder = new TextDecoder('utf-8');
    return decoder.decode(bytes);
}

function main() {
    // 示例
    console.log(str2hex('加密数据')); // 输出: e58aa0e5af86e695b0e68dae
    console.log(hex2str('e58aa0e5af86e695b0e68dae')); // 输出: 加密数据
}

main();

```

python

```python
def str2hex_1(input_str: str) -> str:
    # str -> bytes(utf8) --> byte -> hex_item --> 补0 -> join
    return "".join([hex(i)[2:].rjust(2, "0") for i in input_str.encode("utf8")])
    # return "".join(f'{i:02x}' for i in input_str.encode("utf8"))


def str2hex_2(s):
    # str -> bytes(utf8) -> hex
    import binascii
    return binascii.hexlify(s.encode("utf8")).decode("utf8")


def str2hex_3(s: str) -> str:
    # str -> bytes(utf8) -> hex
    return s.encode("utf8").hex()


def hex2str(hex_str: str) -> str:
    # hex -> bytes -> str
    return bytes.fromhex(hex_str).decode('utf-8')


if __name__ == '__main__':
    # 示例
    text = "加密数据"
    hex_result = str2hex_1(text)
    print(hex_result)  # 输出: e58aa0e5af86e695b0e68dae

    hex_result = str2hex_2(text)
    print(hex_result)  # 输出: e58aa0e5af86e695b0e68dae

    hex_result = str2hex_3(text)
    print(hex_result)  # 输出: e58aa0e5af86e695b0e68dae

```











## bytes & b64

> js端实现b64：
>
> 1）浏览器环境有btoa和atob 
>
> 我们这里自己nodejs实现，这里可以使用Buffer类，对于纯算法实现去看密码学基础中的c和py实现

```js
// 字节数组转 Base64
function bytearray2base64(bytearray) {
    return Buffer.from(bytearray).toString('base64');
}

// Base64 转字节数组
function base642bytearray(base64) {
    return Uint8Array.from(Buffer.from(base64, 'base64'));
}


function main() {
    // 字节数组 → Base64
    const encoder = new TextEncoder();
    const bytes = encoder.encode("1");
    console.log(bytes2base64(bytes)); // MQ==

    // Base64 → 字节数组
    const bytesFromBase64 = base642bytes("MQ==");
    const decoder = new TextDecoder();
    console.log(decoder.decode(bytesFromBase64)); // 1

}

main();
```














## bytes & protobuf

hook出toByteArray的内容，然后复制到python，使用blackProtobuf进行解析，会得到打包用到的 数据（data）和打包外壳（types）











## gzip











# 汇编基础

汇编是我们分析编译型语言，所必备的基础；















# 安卓基础

## 签名校验











# flutter逆向总结

参考:

- [**安卓逆向这档事》番外实战篇3-拨云见日之浅谈Flutter逆向**](https://www.52pojie.cn/thread-1951619-1-1.html)
- [**Android-Flutter逆向**](https://blog.lleavesg.top/article/Flutter-Reverse#9a5b45b33a1549a9a8d19f7fcc75384f)



## 一些经典问题

1. 什么样的app会用flutter开发?

   - 确实有跨平台的需求的

     - 如 `微博` `扇贝单词 ` `reqable`

   - 一定程度上防止逆向的

     - 黑灰类app, 如色情类, 网赌类, 游戏类(捕鱼,棋牌)
     - 安全要求高的类: 腾讯, 邮箱类; 支付类, 微信, 支付宝
     - 部分大厂app的部分版本

     

2.  flutter开发的app有什么难点?

   - 抓包难

     默认不会走系统代理; 默认sslpinning;

     > 解决方法: (1) vpn转发+hook处理; (2) 抓包软件: reqable 或 proxybin

   - 代码位置在so层

     代码逻辑部分或者全部在`libapp.so`中，且ida无法直接反编译出阅读性高的源码。

   

3. 怎么辨别呢?

   - 看lib下有没有 `libapp.so` 和 `libflutter.so`;
   - `assets` 下有 `flutter_assets `之类的 文件夹; 还会有 dexopt; 

   有的话代表 **部分** (或者可能根本没用) 或者全部业务  使用flutter开发;

   > 注意这里的部分或者根本没用, 有的时候只是单纯的障眼法; 
   >
   > 有些app可能某些版本用了flutter, 其他版本就不用了!!
   >
   > 有的app可能有 `libflutter.so` 但是完全不加载,也就是根本不用; 



4. 逆向方法和主流工具

   逆向方法:

   - 静态分析 

     将libapp.so中的快照数据按照其既定格式进行解析，获取业务代码的类的各种信息，包括类的名称、其中方法的偏移等数据，从而辅助逆向工作.

   - 动态分析

     编译修改过的`libflutter.so`并且重新打包到APK中，在启动APP的过程中，由修改过的引擎动态链接库将快照数据获取并且保存.

   

   主流工具:

   - [blutter](https://github.com/worawit/blutter)静态分析

     介绍: [作者写的ppt](https://conference.hitb.org/hitbsecconf2023hkt/materials/D2%20COMMSEC%20-%20B(l)utter%20%E2%80%93%20Reversing%20Flutter%20Applications%20by%20using%20Dart%20Runtime%20-%20Worawit%20Wangwarunyoo.pdf)

   - [reFlutter](https://github.com/Impact-I/reFlutter) 动态分析

     介绍: [作者写的文档](https://swarm.ptsecurity.com/fork-bomb-for-flutter/)

   - 自实现 静态分析

     flutter快照解析文章: 

     - [Reverse engineering Flutter apps (Part 1) (tst.sh)](https://blog.tst.sh/reverse-engineering-flutter-apps-part-1/)
     - [Reverse engineering Flutter apps (Part 2) (tst.sh)](https://blog.tst.sh/reverse-engineering-flutter-apps-part-2/)

   

这里我们常用的方法就是blutter+frida进行静态分析+动态验证就可以搞定大多数了;



## blutter 配置教程

吾爱破解文档有详细教学;









## 定位方法与案例截图

撰写初衷: 目前网上的flutter逆向教程, 案例比较多, 但是总结的定位技巧都比较少, 不像java层的定位有很多方法;

在逆向过程的算法还原中, 定位代码位置的难度是两级分化的, 有的几分钟就能找到, 有的几小时还没找到; 所以我把我常用的定位技巧总结一下; 

> 当然本人总结的定位技巧也不算多, 而且也不一定准确,主要是从案例和源码中总结的;  不一定100%, 目标就是能应用大部分app就行

1. 根据业务功能猜测函数名, 比如登录就找 `login`, 密码加密就找 `encryptpwd` `pwd`, 响应体解密 `decrypt`; 比如参数是sign就搜`sign`
2. 根据算法名来寻找定位; 如 `md5` `aes`
3. 根据flutter正向开发会使用的第三方库的函数名来定位 ; 如`convert`;

其实这些逆向方法 在其他层面如java层,和native层 都是差不多的, 不过flutter开发的 `libapp.so` 更不容易定位;





## 常见flutter逆向案例blog

-  [库迪咖啡(360加固+md5)](https://dawnnnnnn.com/2024/06/:/day/Flutter%20Android%20APP%E9%80%86%E5%90%91/index.html) 工具: blutter 作者: @Dawnnnnnn 

-  [天工ai(仅解决抓包)](https://dawnnnnnn.com/2024/07/:/day/Flutter%20Android%20APP%E9%80%86%E5%90%912/) 工具: 不清楚 作者: @Dawnnnnnn 

- [KO台球(360加固+md5)](https://blog.csdn.net/A_fanyifan/article/details/140412371) 工具: blutter 作者: @带带弟弟学爬虫 

- [入魂一番赏(md5))](https://blog.csdn.net/A_fanyifan/article/details/139727512) 工具: blutter 作者: @带带弟弟学爬虫 

- [联大学堂(RSA)](https://www.bilibili.com/video/BV1ZZ421K7WL) 工具: blutter 作者: @带带弟弟学爬虫 

- 母之蕴(AES) (购买星球赠送视频) 工具: blutter 作者: @带带弟弟学爬虫 

- 兔迹(AES+RSA) (购买星球赠送视频) 工具: blutter 作者: @带带弟弟学爬虫 

  > 视频配套的app版本 测试 网络异常, 疑似api关闭了或者我的网络环境有问题

- 水果派(AES+RSA)  (购买星球赠送视频) 工具: blutter 作者: @带带弟弟学爬虫 

  > 视频配套的app版本 测试  网络异常, 疑似api关闭了或者我的网络环境有问题

- [囧次元（AES+RSA）](https://blog.csdn.net/A_fanyifan/article/details/141462500) 工具: blutter 作者: @带带弟弟学爬虫 

  > 老版本走的是flutter的AES+RSA加密
  >
  > v1.5.7.9 版本有libapp.so但是压根不用, 走的是java层加密



## 案例

1. 糖心vlog AES/CBC/PKCS7 5分钟速通
2. 91  51视频 吃瓜网 海角



## 常用算法

接下来讲一下加解密过程中的常用算法的正向开发和逆向方法

### base64

正向开发:

dart自带的convert库

```dart
import 'dart:convert';

void encryptBase64(String str) {
    print("Base64加密前文本：" + str);
    var content_bytes = utf8.encode(str);
    var digest = base64Encode(content_bytes); // 在这里直接调用
    base64String = digest.toString();
    // 还有的会手动创建编码器，底层实现也是convert
    // var encoder = new Base64Encoder();
    // var base64String = encoder.convert(content_bytes); // 得到字符串
    
    print("Base64加密后文本：" + base64String);
}

void decryptBase64() {
    print("Base64解密前文本：" + base64String);
    base64String = String.fromCharCodes(base64Decode(base64String)); // 在这里直接调用
    print("Base64解密后文本：" + base64String);
}

```

所以可以搜 `base64Encode/decode` 来寻找

如 `dart_convert_Base64Codec::decode_a4421`



### hash

1. 使用的是 [`crypto` ](https://pub-web.flutter-io.cn/packages/crypto)第三方加密库：md5，sha，hmac

   - 正向开发

     > 有些app会模仿这个库自己实现

     ```dart
     import 'package:crypto/crypto.dart';
     import 'dart:convert'; // utf8.encode()需要这个引用
     
     // md5,sha
     void main() {
         var bytes = utf8.encode("需要加密的数据"); // data being hashed
     	var digest = sha256.convert(bytes); // 直接调用对应算法对象，然后传入字节
         // 其他hash算法
         // var digest = sha1.convert(bytes);
         // var digest = md5.convert(bytes);
     
         print("Digest as bytes: ${digest.bytes}");
         print("Digest as hex string: $digest");
     }
     // hmac
     void encryptHMACSHA256(String hmacKey, String hmacValue) {
         print("加密前文本：key:$hmacKey value:$hmacValue");
         var key = utf8.encode(hmacKey);
         var bytes = utf8.encode(hmacValue);
         //第一个参数算法类型就不多说了
         var hmacSha256 = Hmac(sha256, key); // HMAC-SHA256, 这里构造一个对象，传入算法和key
         var digest = hmacSha256.convert(bytes);
         final encryptStr = digest.toString();
         print("SHA256的HMAC加密后文本：key:$hmacKey value:$encryptStr");
     }
     // 分块输入
     import 'dart:convert';
     import 'package:convert/convert.dart';
     import 'package:crypto/crypto.dart';
     
     void main() {
         var firstChunk = utf8.encode("foo");
         var secondChunk = utf8.encode("bar");
     	
         var output = AccumulatorSink<Digest>(); 
         // 创建输入流
         var input = sha1.startChunkedConversion(output);
         input.add(firstChunk);
         input.add(secondChunk); // call `add` for every chunk of input data
         // 输入完毕
         input.close();
         var digest = output.events.single; // 拿到十六进制字符串
     
         print("Digest as bytes: ${digest.bytes}");
         print("Digest as hex string: $digest");
     }
     ```

     

   - 逆向定位方法:

     1. 搜对应hash算法的名字然后跟栈找convert

        比如搜 `md5` ,然后找可疑的hook测试

        这里面主要是convert传入加密的数据，所以我们逆向的时候，遇到参数像是哈希算法的时候主要找convert的调用

        这里值得注意的是，调用都是  `对象.convert` 所以是可以动态调整对象的 (搜 `convert` `hash_Hash_convert`；也就是常说的面向对象中的鸭子模型

        

     2. 案例

        - ko台球

        ![image-20250628220220177](./assets/image-20250628220220177.png)

        ![image-20250628220853712](./assets/image-20250628220853712.png)

        

        - 入魂一番赏

        ![image-20250628220110776](./assets/image-20250628220110776.png)

        ![image-20250628220801648](./assets/image-20250628220801648.png)

        > 这个截图是自定义库实现的, 前面走的并不是 `crypto` 第三方库 ; 不过这个函数内部调用了 `crypto` 的convert函数

     

     

2. 使用第三方库 `cryptography`

   ```dart
   //只有一个加密这么导入就行了
   import 'package:cryptography/cryptography.dart'
   //如果同时使用了两个加密，很容易冲突，使用模块化导出即可
   import 'package:cryptography/cryptography.dart' as cryptography;
   
   //SHA1加密
   Future<void> encryptSHA1ByCryptography(String str) async {
       print("SHA1ByCryptograph加密前文本:" + str);
       final message = utf8.encode(str);
       final algorithm = cryptography.Sha1();
       final hash = await algorithm.hash(message); // 构造算法对象，然后执行.hash
       //转化成16进制字符串
       final encryptStr = getHexString(hash.bytes);
       print("SHA1ByCryptograph加密后文本:" + encryptStr);
   }
   
   //SHA256加密
   Future<void> encryptSHA256ByCryptography(String str) async {
       print("SHA256ByCryptograph加密前文本:" + str);
       final message = utf8.encode(str);
       final algorithm = cryptography.Sha256();
       final hash = await algorithm.hash(message); // 构造算法对象，然后执行.hash
       final encryptStr = getHexString(hash.bytes);
       print("SHA256ByCryptograph加密后文本:" + encryptStr);
   }
   
   //SHA256的HMAC加密
   Future<void> encryptHMACSHA256ByCryptography(String hmacKey, String hmacValue) async {
       print("SHA256ByCryptograph加密前文本:key:$hmacKey value:$hmacValue");
       var key = utf8.encode(hmacKey);
       final bytes = utf8.encode(hmacValue); //这个转化的是accii码走的
       final secretKey = cryptography.SecretKey(key);
   
       final hmac = cryptography.Hmac.sha256(); 
       final mac = await hmac.calculateMac(
           bytes,
           secretKey: secretKey,
       ); // 构造算法对象时传入key，然后执行.calculateMac
       
       //返回的内容是16进制数组，需要转化成16进制字符串，因此不能使用utf8.decode
       final encryptStr = getHexString(mac.bytes);
       print("SHA256ByCryptograph加密后文本:" + encryptStr);
   }
   
   //将16进制数组转化成字符串
   String getHexString(List<int> ints) {
       return ints.map((e) {
           //toRadixString 转化 成 16 进制
           String text = e.toRadixString(16);
           return text.length > 1 ? text : '0$text';
       }).join('');
   }
   ```

   如果使用了这个库，我们需要去找 `.hash` 和 `calculateMac` 方法

   

3. 使用第三方库 [crypt](https://pub-web.flutter-io.cn/packages/crypt)

   ```dart
   import 'package:crypt/crypt.dart';
   
   void main() {
       // Creating crypt strings
   
       // Default rounds and random salt generated
       final c1 = Crypt.sha256('p@ssw0rd');
   
       // Random salt generated
       final c2 = Crypt.sha256('p@ssw0rd', rounds: 10000);
   
       // Default rounds
       final c3 = Crypt.sha256('p@ssw0rd', salt: 'abcdefghijklmnop');
   
       // No defaults used
       final c4 = Crypt.sha256('p@ssw0rd', rounds: 10000,
                               salt: 'abcdefghijklmnop');
   
       // SHA-512
       final d1 = Crypt.sha512('p@ssw0rd');
   	
       // Crypt 对象包含哈希值（hash） 使用的盐（salt） 哈希算法类型（type，这里是 sha512） 迭代轮数（rounds，默认值取决于库的实现）
       // 直接打印会出现 $6$salt$hashedpassword: 6代表算法sha512；salt是随机盐值；hashedpassword是最终结果
       // 所以一般用这个库会指定盐
       print(c1);
       print(c2);
       print(c3);
       print(c4);
       print(d1);
   
       // Comparing a value to a crypt hash
   
       for (final hashString in [
           r'$5$zQUCjEzs9jnrRdCK$dbo1i9WjQjbUwOC4JCRAZHpfd31Dh676vI0L6w0dZw1',
           c1.toString(),
           c2.toString(),
           c3.toString(),
           c4.toString(),
           d1.toString(),
       ]) {
           // Parse the crypt string: this extracts the type, rounds and salt
           final h = Crypt(hashString);
   
           const correctValue = 'p@ssw0rd';
           const wrongValue = '123456';
   
           if (!h.match(correctValue)) {
               print('Error: unexpected non-match: $correctValue');
           }
   
           if (h.match(wrongValue)) {
               print('Error: unexpected match: $wrongValue');
           }
       }
   }
   ```

   

### AES

正向开发:

使用的是  `encrypt` 加密库

支持很多模式，`CBC` `ECB` `CFB-64` `OFB-64` `SIC`

```dart
class AESUtil {
    static String generateAES(String data, String keyStr, String ivStr) {
        final plainText = data;
        final key = Key.fromUtf8(keyStr);
        final iv = IV.fromUtf8(ivStr);
        final encrypter = Encrypter(AES(key, mode: AESMode.cbc));// 指定使用CBC模式(AES/CBC/PKCS5PADDING)
        final encrypted = encrypter.encrypt(plainText, iv: iv);
        // final encrypter = Encrypter(AES(key, mode: AESMode.cbc)); 默认是AESMode.sic
        // final encrypter = Encrypter(AES(key, mode: AESMode.cbc, padding: null)); // NoPadding

        print("generateAES:" + encrypted.base64);
        return encrypted.base64;
    }
}
```

这里的key是通过AES传的；iv和明文是通过encrypt传的；



逆向方法:

1. 首先要判断出AES

   > 根据AES算法特点, **bytes字节数是16的倍数** ; 这只能代表可能是AES

2. 搜AES寻找 `encrypt` `encryptBytes` `convert` 之类的;

   ![image-20250628222430692](./assets/image-20250628222430692.png)

   > 目的是寻找key和iv

   ![image-20250628222034554](./assets/image-20250628222034554.png)

   > 这里就能找到key&iv了,按道理也能找到明文; 不过这里都只是初始化函数, 我们可以hook更直接的加密函数;
   >
   > hook这里涉及到的函数就能找到mode了;

   或者在去找这里的 `encrypt` 然后交叉引用找到AES验证顺便找key和iv

   > 这里的 `encrypt` 一般是为了找aes明文的

   ![image-20250628221508941](./assets/image-20250628221508941.png)

   这个一般会继续调用 `encryptBytes`

   ![image-20250628222545113](./assets/image-20250628222545113.png)

   继续跟

   ![image-20250628222648677](./assets/image-20250628222648677.png)

   这几个 `encrypt` 函数都包含了明文,找一个方便的就行;



### RSA

正向开发:

1. 首先pubspec.yaml中添加依赖

2. 在`assets` 目录下新建`rsa_key`文件夹，用来存储我们的公钥私钥文件

   > 我们逆向时去 `assets` 下寻找密钥; 一般flutter打包会额外创建一个文件夹叫 `flutter_assets`

   给一个案例截图

   ![image-20250628221106139](./assets/image-20250628221106139.png)

3.  在`pubspec.yaml`文件中添加公钥私钥文件。

    ```yaml
    flutter:
      # The following line ensures that the Material Icons font is
      # included with your application, so that you can use the icons in
      # the material Icons class.
      uses-material-design: true
    
      # To add assets to your application, add an assets section, like this:
      assets:
        - assets/fonts/iconfont.json
        - assets/rsa_key/rsa_public_key.pem
        - assets/rsa_key/rsa_private_key.pem
        #   - images/a_dot_burr.jpeg
        #   - images/a_dot_ham.jpeg
        - assets/images/home_logo.png
    ```

4. 在`lib/utils`目录下新建`rsa_encrypt.dart`文件，用来开发我们的加密解密工具类。

   ```dart
   import 'dart:convert';
   import 'package:encrypt/encrypt.dart';
   import 'package:flutter/services.dart';
   import 'package:pointycastle/asymmetric/api.dart';
   class Encrypt {
       ///  加密
       static encryption(content) async {
           final parser = RSAKeyParser();
           // 加载密钥
           String publicKeyString = await rootBundle.loadString('assets/rsa_key/rsa_public_key.pem'); 
           print('publicKeyString=$publicKeyString'); // 注意这一行的输出
           // 实现加密
           RSAPublicKey publicKey = parser.parse(publicKeyString) as RSAPublicKey;
           final encrypter = Encrypter(RSA(publicKey: publicKey));
           // 转base64
           return encrypter.encrypt(content).base64;
       }
       /// 解密
       static Future<String> decrypt(String decoded) async {
           final parser = RSAKeyParser();
           String privateKeyString = await rootBundle.loadString('assets/rsa_key/rsa_private_key.pem');
           final privateKey = parser.parse(privateKeyString) as RSAPrivateKey;
           final encrypter = Encrypter(RSA(privateKey: privateKey));
           return encrypter.decrypt(Encrypted.fromBase64(decoded));
       }
   }
   
   ```



逆向方法:

1. 先去assets找到密钥

   > 找不到的话先看2, 顺藤摸瓜也能找到的]

   实在找不到的话 ida搜索 strings试试; 一般会有路径和文件名

   ![image-20250628224403644](./assets/image-20250628224403644.png)

   

2. 找 `parse` 函数来定位明文和密钥; 或者搜 `RSA` `decrypt` `encrypt`

   ![image-20250628223440456](./assets/image-20250628223440456.png)

   ![image-20250628223552315](./assets/image-20250628223552315.png)

   比如这个函数调用convert函数传递bytes数据,然后调用 `encryptBytes` 实现加密

   ![image-20250628223825202](./assets/image-20250628223825202.png)

   > 这里就能找到明文了, 密钥可能还得找找

   里面又调用了 前面提到的 `RSA_encrypt` 函数

   ![image-20250628223928219](./assets/image-20250628223928219.png)

   这个函数里面就会有密钥以及明文, 可以hook拿







# py爬虫常用信息伪造

在这一章节我会把爬虫中所有需要伪造的东西都列出来，并且给出伪造代码

> 如果可以的话，我会把这些信息打包成pip包

## 时间

1. time模块

   - 时间戳

     ```python
     def timestamp() -> str:
         return int(time.time())
     
     def timestamp_ms() -> str:
         return int(time.time() * 1000)
     
     ```

   - 格式化字符串

     ```python
     timestamp = time.time()
     time_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))
     time_str = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(timestamp))
     ```

   - 时间字符串转时间戳

     ```python
     time_str = '2025-06-18 21:33:49'
     # 转时间元组
     print(time.strptime(time_str, '%Y-%m-%d %H:%M:%S'))
     # 时间字符串转换成时间戳
     timestamp = time.mktime(time.strptime(time_str, '%Y-%m-%d %H:%M:%S'))
     
     ```

2. datetime模块

   - 时间戳

     ```python
     from datetime import datetime
     
     time_str = datetime.now() # 2025-06-18 21:37:02.490199
     # 时间元组
     time_tuple = datetime.now().timetuple()
     ```

   - datetime对象转**时间字符串和时间戳**

     ```python
     # datetime对象转换成时间字符串
     datetime_str = datetime.strftime(datetime.now(), '%Y-%m-%d %H:%M:%S')
     print(datetime_str) #2019-05-29 17:22:37
     
     # datetime对象转换成时间戳
     datetime_stamp = datetime.timestamp(datetime.now())
     print(datetime_stamp) # 1559121757.343784
     ```

   - 时间字符串转时间戳

     ```python
     # 时间字符串转datetime对象，再转时间戳
     datetime_stamp2 = datetime.timestamp(datetime.strptime(datetime_str, '%Y-%m-%d %H:%M:%S'))
     print(datetime_stamp2) # 1559121757.0
     ```

   - 时间戳转时间字符串

     ```python
     # 时间戳转datetime对象，再转时间字符串
     datetime_str2 = datetime.strftime(datetime.fromtimestamp(datetime_stamp2), '%Y-%m-%d %H:%M:%S')
     print(datetime_str2)
     ```

   - 带毫秒的时间字符串

     ```python
     print(datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S.%f')[:-3])
     ```
     


## imei

规则:        

1. 第一部分 TAC，Type Allocation Code，类型分配码

   由8位数字组成（早期是6位），是区分手机品牌和型号的编码，该代码由GSMA及其授权机构分配。
   其中TAC码前两位又是分配机构标识（Reporting Body Identifier），是授权IMEI码分配机构的代码，如01为美国CTIA，35为英国BABT，86为中国TAF。

2. 第二部分 FAC，Final Assembly Code，最终装配地代码
3. 由2位数字构成，仅在早期TAC码为6位的手机中存在，所以TAC和FAC码合计一共8位数字。
   该FAC码用于生产商内部区分生产地代码。

3. 第三部分 SNR，Serial Number，序列号

   由第9位开始的6位数字组成，区分每部手机的生产序列号。

4. 第四部分 CD，Check Digit，验证码

   由前14位数字通过Luhn算法计算得出。

5. 第五部分 SVN，Software Version Number，软件版本号

   区分同型号手机出厂时使用的不同软件版本，仅在部分品牌的部分机型中存在。

   


```python
def validate_imei(imei):
    """验证IMEI号码是否有效"""
    if len(imei) != 15 or not imei.isdigit():
        return False

    imei_base = imei[:14]
    expected_check_digit = calculate_luhn_check_digit(imei_base)
    return expected_check_digit == imei[-1]

def calculate_luhn_check_digit(imei_base):
    """计算Luhn校验位"""
    """
        序号是倒置的 D14 D13 D12 D11 D10 D9 D8 D7 D6 D5 D4 D3 D2 D1 D0
        (1) 取奇数位: 则为D13 D11 D9 D7 D5 D3 D1【代码index%2==1】
        (2) 奇数位翻倍
    """
    total = 0
    for i, digit in enumerate(map(int, imei_base)):
        if i % 2 == 1:  # 奇数位: 乘以2【代码中从0开始】, 偶数位直接加
            digit *= 2
            if digit > 9: # 两位数则，十位数+个位数
                digit = digit // 10 + digit % 10
        total += digit
    check_digit = (10 - (total % 10)) % 10
    return str(check_digit)

def generate_imei() -> str:
    """
    生成符合规范的IMEI号码
    """
    # 现代IMEI结构：TAC+FAC(8位) + SNR(6位) + 校验位(1位)
    tac_fac = "".join([str(random.randint(0, 9)) for _ in range(8)])
    snr = "".join([str(random.randint(0, 9)) for _ in range(6)])

    imei_base = tac_fac + snr
    check_digit = calculate_luhn_check_digit(imei_base)
    return imei_base + check_digit


```





## mac地址

mac 地址 **由六组两个十六进制数字组成，每组与下一组用冒号分隔，例如aa：bb：cc：dd：ee：00**

有的mac地址使用 `-` 连接

前五组十六进制数字派生自交换机，对于交换机上的所有接口都是相同的。

> 手机查看mac地址
>
> ```bash
> C:\Users\xxx>adb shell ip addr show wlan0
> 26: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 3000
>     link/ether 7e:3e:d1:83:85:3c brd ff:ff:ff:ff:ff:ff
>     inet 192.168.84.209/24 brd 192.168.84.255 scope global wlan0
>        valid_lft forever preferred_lft forever
>     inet6 fe80::7c3e:d1ff:fe83:853c/64 scope link
>        valid_lft forever preferred_lft forever
> ```
>
> 7e:3e:d1:83:85:3c就是手机的mac地址了；ff:ff:ff:ff:ff:ff是对于的子网掩码

```python
import random

def generate_mac() -> str:
    return ":".join("".join(random.sample("0123456789abcdef",2)) for i in range(6))

```

# root技术

## 常见root手法

1. 普通面具 magisk
2. 其他面具如 狐妖面具、apatch面具
3. kernelSu



## root前置条件

解bl锁





## root检测









## 对抗检测

1. 面具隐藏+模块隐藏

2. 其他面具隐藏

3. 内核su隐藏

4. hook绕过（通杀或者对app针对性hook）

   https://github.com/AshenOneYe/FridaAntiRootDetection，下面的脚本就是

5. aosp隐藏su

```js
const commonPaths = [
    "/data/local/bin/su",
    "/data/local/su",
    "/data/local/xbin/su",
    "/dev/com.koushikdutta.superuser.daemon/",
    "/sbin/su",
    "/system/app/Superuser.apk",
    "/system/bin/failsafe/su",
    "/system/bin/su",
    "/su/bin/su",
    "/system/etc/init.d/99SuperSUDaemon",
    "/system/sd/xbin/su",
    "/system/xbin/busybox",
    "/system/xbin/daemonsu",
    "/system/xbin/su",
    "/system/sbin/su",
    "/vendor/bin/su",
    "/cache/su",
    "/data/su",
    "/dev/su",
    "/system/bin/.ext/su",
    "/system/usr/we-need-root/su",
    "/system/app/Kinguser.apk",
    "/data/adb/magisk",
    "/sbin/.magisk",
    "/cache/.disable_magisk",
    "/dev/.magisk.unblock",
    "/cache/magisk.log",
    "/data/adb/magisk.img",
    "/data/adb/magisk.db",
    "/data/adb/magisk_simple",
    "/init.magisk.rc",
    "/system/xbin/ku.sud",
    "/data/adb/ksu",
    "/data/adb/ksud"
];

const ROOTmanagementApp = [
    "com.noshufou.android.su",
    "com.noshufou.android.su.elite",
    "eu.chainfire.supersu",
    "com.koushikdutta.superuser",
    "com.thirdparty.superuser",
    "com.yellowes.su",
    "com.koushikdutta.rommanager",
    "com.koushikdutta.rommanager.license",
    "com.dimonvideo.luckypatcher",
    "com.chelpus.lackypatch",
    "com.ramdroid.appquarantine",
    "com.ramdroid.appquarantinepro",
    "com.topjohnwu.magisk",
    "me.weishu.kernelsu"
];



function stackTraceHere(isLog){
    var Exception = Java.use('java.lang.Exception');
    var Log = Java.use('android.util.Log');
    var stackinfo = Log.getStackTraceString(Exception.$new())
    if(isLog){
        console.log(stackinfo)
    }else{
        return stackinfo
    }
}

function stackTraceNativeHere(isLog){
    var backtrace = Thread.backtrace(this.context, Backtracer.ACCURATE)
    .map(DebugSymbol.fromAddress)
    .join("\n\t");
    console.log(backtrace)
}


function bypassJavaFileCheck(){
    var UnixFileSystem = Java.use("java.io.UnixFileSystem")
    UnixFileSystem.checkAccess.implementation = function(file,access){

        var stack = stackTraceHere(false)

        const filename = file.getAbsolutePath();

        if (filename.indexOf("magisk") >= 0) {
            console.log("Anti Root Detect - check file: " + filename)
            return false;
        }

        if (commonPaths.indexOf(filename) >= 0) {
            console.log("Anti Root Detect - check file: " + filename)
            return false;
        }

        return this.checkAccess(file,access)
    }
}

function bypassNativeFileCheck(){
    var fopen = Module.findExportByName("libc.so","fopen")
    Interceptor.attach(fopen,{
        onEnter:function(args){
            this.inputPath = args[0].readUtf8String()
        },
        onLeave:function(retval){
            if(retval.toInt32() != 0){
                if (commonPaths.indexOf(this.inputPath) >= 0) {
                    console.log("Anti Root Detect - fopen : " + this.inputPath)
                    retval.replace(ptr(0x0))
                }
            }
        }
    })

    var access = Module.findExportByName("libc.so","access")
    Interceptor.attach(access,{
        onEnter:function(args){
            this.inputPath = args[0].readUtf8String()
        },
        onLeave:function(retval){
            if(retval.toInt32()==0){
                if(commonPaths.indexOf(this.inputPath) >= 0){
                    console.log("Anti Root Detect - access : " + this.inputPath)
                    retval.replace(ptr(-1))
                }
            }
        }
    })
}

function setProp(){
    var Build = Java.use("android.os.Build")
    var TAGS = Build.class.getDeclaredField("TAGS")
    TAGS.setAccessible(true)
    TAGS.set(null,"release-keys")

    var FINGERPRINT = Build.class.getDeclaredField("FINGERPRINT")
    FINGERPRINT.setAccessible(true)
    FINGERPRINT.set(null,"google/crosshatch/crosshatch:10/QQ3A.200805.001/6578210:user/release-keys")

    // Build.deriveFingerprint.inplementation = function(){
    //     var ret = this.deriveFingerprint() //该函数无法通过反射调用
    //     console.log(ret)
    //     return ret
    // }

    var system_property_get = Module.findExportByName("libc.so", "__system_property_get")
    Interceptor.attach(system_property_get,{
        onEnter(args){
            this.key = args[0].readCString()
            this.ret = args[1]
        },
        onLeave(ret){
            if(this.key == "ro.build.fingerprint"){
                var tmp = "google/crosshatch/crosshatch:10/QQ3A.200805.001/6578210:user/release-keys"
                var p = Memory.allocUtf8String(tmp)
                Memory.copy(this.ret,p,tmp.length+1)
            }
        }
    })

}

//android.app.PackageManager
function bypassRootAppCheck(){
    var ApplicationPackageManager = Java.use("android.app.ApplicationPackageManager")
    ApplicationPackageManager.getPackageInfo.overload('java.lang.String', 'int').implementation = function(str,i){
        // console.log(str)
        if (ROOTmanagementApp.indexOf(str) >= 0) {
            console.log("Anti Root Detect - check package : " + str)
            str = "ashen.one.ye.not.found"
        }
        return this.getPackageInfo(str,i)
    }

    //shell pm check
}

function bypassShellCheck(){
    var String = Java.use('java.lang.String')

    var ProcessImpl = Java.use("java.lang.ProcessImpl")
    ProcessImpl.start.implementation = function(cmdarray,env,dir,redirects,redirectErrorStream){

        if(cmdarray[0] == "mount"){
            console.log("Anti Root Detect - Shell : " + cmdarray.toString())
            arguments[0] = Java.array('java.lang.String',[String.$new("")])
            return ProcessImpl.start.apply(this,arguments)
        }

        if(cmdarray[0] == "getprop"){
            console.log("Anti Root Detect - Shell : " + cmdarray.toString())
            const prop = [
                "ro.secure",
                "ro.debuggable"
            ];
            if(prop.indexOf(cmdarray[1]) >= 0){
                arguments[0] = Java.array('java.lang.String',[String.$new("")])
                return ProcessImpl.start.apply(this,arguments)
            }
        }

        if(cmdarray[0].indexOf("which") >= 0){
            const prop = [
                "su"
            ];
            if(prop.indexOf(cmdarray[1]) >= 0){
                console.log("Anti Root Detect - Shell : " + cmdarray.toString())
                arguments[0] = Java.array('java.lang.String',[String.$new("")])
                return ProcessImpl.start.apply(this,arguments)
            }
        }

        return ProcessImpl.start.apply(this,arguments)
    }
}


console.log("Attach")
bypassNativeFileCheck()
bypassJavaFileCheck()
setProp()
bypassRootAppCheck()
bypassShellCheck()
```







## aosp源码定制

原理:修改aosp源代码,在fork子进程的时候注入frida-gadget

[ubuntu 20.04系统AOSP(Android 11)集成Frida](https://www.mobibrw.com/2021/28588#/)
[AOSP Android 10内置FridaGadget实践01](https://www.52pojie.cn/thread-1740214-1-1.html#/)
[AOSP Android 10内置FridaGadget实践02(完)](https://www.52pojie.cn/thread-1748101-1-1.html)|







# 抓包技术

## 手机抓包

讲一下中间人抓包的本质：手机转抓包软件的证书，从而可以解密https流量

而安卓7+，证书装在用户证书，安卓是不信任这个证书的，所以我们需要移到系统证书下；

而想移动到系统证书下，需要把对应目录挂载为可读写，这是需要root的（实际现在很多手机即使root也不好挂载）

因此我们需要对手机进行root，这里可以去看[root技术](#root技术)



## 配置抓包

手机wifi挂代理把流量转发到抓包软件，

抓包软件有很多，看你喜欢哪个用哪个，这里可以是charles，mitmproxy，reqable，burp，wireshark等等

比如charles就需要设置wifi代理 `192.168.31.170:8888`，然后浏览器访问 `chls.pro`，后面这一步是下载对应你电脑的安卓需要的charles证书，下载好，安装CA证书；

这时候证书已经到了用户证书了，如果是低版本安卓，此时随便抓包了；但是我们现在都是高版本(7+)，所以需要移动到系统证书下；

我们使用 movecert的xp模块，他会自动把用户证书移动到系统证书下；

移动好之后，就可以正常抓包了；



## 转发流量

常见的一些方式

1. wifi代理

2. vpn代理转发

   >  socksDroid、postern、shadowrocket

   - http/https 转发
   - sockets 转发

   有这两种方式，我们一般用后面的 sockets

3. 无痕代理（我用的少）



实际使用时，我们使用 reqable 进行抓包是最方便的，其ui非常清爽，功能丰富；





## 海外app抓包

1. 抓包软件再挂一个能访问海外网站的代理就行

   clash配置端口，然后抓包软件设置clash的端口就行；

2. 电脑流量强制走底层vpn软件

   如：快连vpn



## 代理相关理论知识

正向代理：

- 你的电脑 - 代理服务器 - 目标服务器

反向代理：



透明代理：

> 走的是iptable

匿名代理：

> 加密的透明代理



### 关于iptables

iptable原理（透明代理）：

 - linux内核提供的防火墙工具是**Netfilter/Iptables**。

 - **Netfilter**是由linux内核集成的IP数据包过滤系统，其工作在内核内部，而**Iptables**则是让用户定义规则集的表结构。

 - 也就是，**iptables**是一个命令行工具，位于用户空间，它真正操作的框架实现在内核当中。

 - `Iptables`主要工作在OSI七层的2.3.4层，好像也没比VPN的工作协议低，反而还有高的。

   > 测试结果证明，iptables不是由于协议低，而是没有出现`tun0`或者`ppp0`这两个关键的网卡特征，所以成功绕过了VPN的检测。所以也叫做透明代理

 [一篇文章解析 各种代理区别](https://zhuanlan.zhihu.com/p/68560128)







## 抓包对抗

-  [APP代理和VPN检测绕过对抗](https://sanshiok.com/archive/8.html)
-  [一篇文章解析 各种代理区别](https://zhuanlan.zhihu.com/p/68560128)

### wifi代理转发检测

不开代理正常数据返回，开了代理就返回不了

**代表软件**：安居客v16.13.2



原理

1. java端可以读出来你是否使用代理
2. java端也可以设置强行不走代理



正向实现方式

1. 系统类

   ```java
   // 也可以这样
   String host = System.getProperty("https.proxyHost");
   String port = System.getProperty("https.proxyPort");
   
   // 直接不走代理
   new OkHttpClient().newBuilder().proxy(Proxy.NO_PROXY).build();
   ```

2. 使用SystemProperties类

   ```java
   import android.os.SystemProperties;
   
   String proxyHost = SystemProperties.get("http.proxyHost");
   String proxyPort = SystemProperties.get("http.proxyPort");
   
   if (proxyHost != null && proxyPort != null) {
       // 代理已设置
   } else {
       // 未设置代理
   }
   ```

3. 使用ConnectivityManager类

   ```java
   import android.content.Context;
   import android.net.ConnectivityManager;
   import android.net.NetworkInfo;
   
   public boolean isProxySet(Context context) {
       ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
       NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
   
       if (activeNetwork != null && activeNetwork.isConnected()) {
           if (activeNetwork.getType() == ConnectivityManager.TYPE_WIFI) {
               // Wi-Fi连接，无需代理
               return false;
           } else if (activeNetwork.getType() == ConnectivityManager.TYPE_MOBILE) {
               String proxyHost = android.net.Proxy.getDefaultHost();
               return (proxyHost != null && proxyHost.length() > 0);
           }
       }
   
       return false; // 未设置代理
   }
   ```

4. 使用Java的URL类 不走代理

   ```java
   import java.net.Proxy;
   import java.net.URL;
   import java.net.URLConnection;
   
   try {
       URL url = new URL("http://www.example.com");
       URLConnection connection = url.openConnection(Proxy.NO_PROXY);
       // 无代理设置
   } catch (Exception e) {
       // 代理设置
   }
   ```

   > NO_PROXY实际上就是type属性为DIRECT的一个Proxy对象，这个type有三种：
   >
   > - DIRECT 、 HTTP 、SOCKS
   >
   > 所以，`Proxy.NO_PROXY`的意思是connection的请求是直连。
   > 此时若通过系统进行代理，app对外请求会失效，也就是视觉上看到的卡死状态，就是不让走系统代理。



如何对抗：

1. hook对抗
2. 更换转发流量的方式，如vpn



hook对抗代码

```js
function bypass_proxyCheck() {
    Java.perform(function () {
        // 1. 绕过 SystemProperties 类
        var SystemProperties = Java.use('android.os.SystemProperties');
        SystemProperties.get.overload('java.lang.String').implementation = function (key) {
            if (key.startsWith('http.proxy') || key.startsWith('https.proxy') || key.startsWith('socks.proxy')) {
                console.log('[*] 拦截代理检测(SystemProperties): ' + key + ' -> null');
                return null;
            }
            return this.get(key);
        };

        // 2. 绕过系统检测
        var System = Java.use('java.lang.System');
    	System.getProperty.overload('java.lang.String').implementation = function(key) {
            if(key=="https.proxyHost" || key=="https.proxyPort"){
                return null;
            }
        return this.getProperty(key);
        }
        
        // 3. 绕过 okhttp
        var Builder = Java.use("okhttp3.OkHttpClient$Builder");

        Builder.proxy.implementation = function (proxy) {
            var res = this.proxy(null);
            return res;
        }
        // 4. 绕过 ConnectivityManager 类
        var Proxy = Java.use('android.net.Proxy');
        Proxy.getDefaultHost.implementation = function () {
            console.log('[*] 拦截代理检测(Proxy): getDefaultHost() -> null');
            return null;
        };

        // 5. 绕过 Java URL 类
        var URL = Java.use('java.net.URL');
        URL.openConnection.overload('java.net.Proxy').implementation = function (proxy) {
            console.log('[*] 拦截代理检测(URL): openConnection(Proxy) -> 使用NO_PROXY');
            return this.openConnection(Java.use('java.net.Proxy').NO_PROXY.value);
        };
        
    });
}
setImmediate(bypass_proxyCheck);
```



### vpn代理转发检测

常用软件：Postern、SocksDroid、VProxid、Reqable、ProxyDroid、[PCAPdroid](https://github.com/emanuele-f/PCAPdroid)

> VProxid`据说可以理解是`Proxifier`的手机版；有时 `postern` 抓不了的我们用 `VProxid

现象

开了vpn就各种风控，不让访问；全部关掉后就正常

**代表软件**: 拼多多v6.29.0



原理

使用vpn转发的话，`ifconfig` 一般是tun0字样

```bash
ip addr | grep -E ".*: <"
```

```bash
adb shell ip link show
```

开了vpn：

> 26: wlan0: 
> 27: p2p0: 
> 30: tun0: 

没开vpn：

> 26: wlan0:
> 27: p2p0: 



检测方式如下：

1. 把vpn转发后的ip地址（也就是服务器收到的ip地址）与已有公开的vpn的地址表对比

2. dns解析验证：VPN连接通常会通过特定的DNS服务器进行解析。比如10.0

3. 判断网络接口名字包含`ppp0`或`tun0` 或 `tap0`
   - ppp0 点对点协议接口
   - tun0/tap0 虚拟网络接口

4. 获取当前网络 `Transpoart` 字样

5. 协议识别 `java.net.DatagramPacket` 类



解决方案

1. hook--`java.net.NetworkInterface` 的 `getName` 和 `getAll` 的返回值

   > 检测到 `ppp0` 和tun0修改成正常的 `eth0` `wlan0` `rmnet0` ``rmnet_data0` `
   >
   > - Wi-Fi 连接：通常是 `wlan0`; 
   > - 移动数据：通常是 `rmnet0`、`rmnet_data0` 或类似名称
   > - **VPN 连接**：(1) IPsec/L2TP可能使用 `ppp0` (2) OpenVPN/Shadowsocks：通常使用 `tun0`
   > - USB 共享网络：(1) 手机作为热点`rndis0` 或 `usb0` (2) 手机连接到电脑 `ppp0`（如果通过 PPP 协议）

   ```js
   // 篡改检测
   let String = Java.use("java.lang.String");
   let NetworkInterface = Java.use("java.net.NetworkInterface");
   NetworkInterface.getName.implementation = function () {
       console.log("call java.net.NetworkInterface.getName()");
       var result = this.getName();
       console.log("find getName：", result);
       if (result && (result.indexOf("ppp0") > -1 || result.indexOf("tun0") > -1)) {
           return String.$new("rmnet_data0");
       }
   }
   // 篡改getAll(hooker工具包js)
   NetworkInterface.getAll.implementation = function () {
       var nis = this.getAll();
       console.log("call java.net.NetworkInterface.getAll()");
       nis.forEach(function (ni) {
           if (ni.name.value.indexOf("tun0") >= 0 || ni.name.value.indexOf("ppp0") >= 0 || ni.displayName.value.indexOf("tun0") >= 0 || ni.displayName.value.indexOf("ppp0") >= 0) {
               ni.name.value = "rmnet_data0";
               ni.displayName.value = "rmnet_data0";
           }
       })
       return nis;
   }
   ```

2. hook--`android.net.ConnectivityManager `的 `getNetworkCapabilities` 返回值为null； 

   > - 以及 `getNetworkInfo()` 传入17代表找到了vpn，正在查询对应信息 （这部分来自hooker工具包）

   ```js
   var can_hook = false;
   // 检测监听
   let ConnectivityManager = Java.use("android.net.ConnectivityManager");
   ConnectivityManager.getNetworkInfo.overload('int').implementation = function () {
       if (arguments[0] === 17) {
           can_hook = true
       }
       let ret = this["getNetworkInfo"](arguments[0]);
       console.log("find getNetworkInfo：", ret)
       return ret;
   }
   // 篡改返回值
   let NetworkInfo = Java.use("android.net.NetworkInfo")
   NetworkInfo.isConnected.implementation = function () {
       let ret = this.isConnected()
       if (can_hook) {
           ret = false
           can_hook = false
           console.log("call isConnected function !!!")
       }
       return ret
   }
   // 禁用网络能力检测
   ConnectivityManager.getNetworkCapabilities.implementation = function (arg) {
       let result = this["getNetworkCapabilities"](arg);
       console.log("find getNetworkCapabilities：", result);
       return null;
   }
   ```

3. `android.net.NetworkCapabilities.NetworkCapabilities` 的 `hasTransport` 表示是否转发

   ```js
   // 篡改是否转发
   let NetworkCapabilities = Java.use("android.net.NetworkCapabilities");
   NetworkCapabilities.hasTransport.implementation = function (v) {
       console.log(v);
       let res = this["hasTransport"](v);
       console.log("res hasTransport ==> ", res)
       return false;
   }
   // 篡改vpn为wifi
   NetworkCapabilities.transportNameOf.overload('int').implementation = function () {
       let ret = this["transportNameOf"](arguments[0]);
       if (ret.indexOf("VPN") >= 0) {
           return "WIFI";
       }
       return ret;
   }
   ```















# hook技术





## java层的通用hook定位

### 基本hook

1. Hook普通方法、打印参数和修改返回值

   ```js
   //定义一个名为hookTest1的函数
   function hookTest1(){
           //获取一个名为"类名"的Java类，并将其实例赋值给JavaScript变量utils
       var utils = Java.use("类名");
       //修改"类名"的"method"方法的实现。这个新的实现会接收两个参数（a和b）
       utils.method.implementation = function(a, b){
               //将参数a和b的值改为123和456。
           a = 123;
           b = 456;
           //调用修改过的"method"方法，并将返回值存储在`retval`变量中
           var retval = this.method(a, b);
           //在控制台上打印参数a，b的值以及"method"方法的返回值
           console.log(a, b, retval);
           //返回"method"方法的返回值
           return retval;
       }
   }
   
   ```





2. Hook重载参数

   ```js
   // .overload()
   // .overload('自定义参数')
   // .overload('int')
   function hookTest2(){
       var utils = Java.use("com.zj.wuaipojie.Demo");
       //overload定义重载函数，根据函数的参数类型填
       utils.Inner.overload('com.zj.wuaipojie.Demo$Animal','java.lang.String').implementation = function(a，b){
           b = "aaaaaaaaaa";
           this.Inner(a,b);
           console.log(b);
       }
   }
   
   ```



3. hook构造函数

   ```js
   function hookTest3(){
       var utils = Java.use("com.zj.wuaipojie.Demo");
       //修改类的构造函数的实现，$init表示构造函数
       utils.$init.overload('java.lang.String').implementation = function(str){
           console.log(str);
           str = "52";
           this.$init(str);
       }
   }
   
   ```




4. Hook字段

   ```js
   function hookTest5(){
       Java.perform(function(){
           //静态字段的修改
           var utils = Java.use("com.zj.wuaipojie.Demo");
           //修改类的静态字段"flag"的值
           utils.staticField.value = "我是被修改的静态变量";
           console.log(utils.staticField.value);
           //非静态字段的修改
           //使用`Java.choose()`枚举类的所有实例
           Java.choose("com.zj.wuaipojie.Demo", {
               onMatch: function(obj){
                       //修改实例的非静态字段"_privateInt"的值为"123456"，并修改非静态字段"privateInt"的值为9999。
                   obj._privateInt.value = "123456"; //字段名与函数名相同 前面加个下划线
                   obj.privateInt.value = 9999;
               },
               onComplete: function(){
   
               }
           });
       });
   
   }
   ```

   

5. Hook内部类

   ```js
   function hookTest6(){
       Java.perform(function(){
           //内部类
           var innerClass = Java.use("com.zj.wuaipojie.Demo$innerClass");
           console.log(innerClass);
           innerClass.$init.implementation = function(){
               console.log("eeeeeeee");
           }
   
       });
   }
   
   ```



6. 枚举所有的类与类的所有方法

   ```js
   function hookTest7(){
       Java.perform(function(){
           //枚举所有的类与类的所有方法,异步枚举
           Java.enumerateLoadedClasses({
               onMatch: function(name,handle){
                       //过滤类名
                   if(name.indexOf("com.zj.wuaipojie.Demo") !=-1){
                       console.log(name);
                       var clazz =Java.use(name);
                       console.log(clazz);
                       var methods = clazz.class.getDeclaredMethods();
                       console.log(methods);
                   }
               },
               onComplete: function(){}
           })
       })
   }
   
   ```

   





Map

- put

  ```js
  function hook_put() {
      Java.perform(function () {
          let Map = Java.use("java.util.Map");
          Map.put.implementation = function (key, value) {
              let result = this.put(key, value);
              if (key != null && (key.equals("key") || key.equals("content"))) {
                  console.log(`HashMap.put is called: key=${key}, value=${value}`);
                  showStacks();
              }
              return result;
          };
      })
  }
  ```

  



- 遍历

  1.  写辅助函数
  
     ```js
     function iterateMap(map) {
         if (map == null) {
             console.log("Map is null");
             return;
         }
         
         try {
             var keyset = map.keySet();
             var it = keyset.iterator();
             console.log("Map contents:");
             while(it.hasNext()){
                 var key = it.next();
                 var value = map.get(key);
                 // 处理 key 和 value 可能为 null 的情况
                 var keystr = key ? key.toString() : "null";
                 var valuestr = value ? value.toString() : "null";
                 console.log(keystr + " = " + valuestr);
             }
         } catch (e) {
             console.log("Error iterating map: " + e);
         }
     }
     ```
  
  2. 类型转换
  
     我们只需要把map使用 `Java.cast(对象,java类型)` 之后再打印就是正常显示的了





### HashMap

```js
var HashMap = Java.use('java.util.HashMap');
HashMap.put.implementation = function(a, b){
    if(a == 'username'){
        showStacks();
        console.log('HashMap: ', a, b);
    }
    return this.put(a, b);
}
```



### Base64

我们可以拦截java端的base64

> 适用于加密过程比较复杂，没有完全使用标准加密，这时候就可以hook一下base64；
>
> 因为这个一般不会手动去写，虽然也不是很难

1. android的base64
    ```js
    var Base64_android = Java.use("android.util.Base64");
    Base64_android.encodeToString.overload('[B', 'int').implementation = function (a, b) {
        console.log("base64.encodeToString: ", JSON.stringify(a));
        var result = this.encodeToString(a, b);
        console.log("base64.encodeToString result: ", result)
        // 这里可以根据转换后的结果进行过滤
        showStacks();
        return result;
    }
    
    ```

2. java的b64

   这个很常见，一般都是unidbg的时候用到（

   ```js
   var javaBase64 = Java.use("java.util.Base64");
   // Hook Encoder 实例
   var base64Encoder = javaBase64.getEncoder();
   Java.use("java.util.Base64$Encoder").encodeToString.overload('[B').implementation = function(input) {
       var result = this.encodeToString(input);
       console.log("\n[java.util.Base64.Encoder.encodeToString]");
       console.log("Input: " + bytesToHex(input));
       console.log("Result: " + result);
       return result;
   };
   
   // Hook Decoder 实例
   var base64Decoder = javaBase64.getDecoder();
   Java.use("java.util.Base64$Decoder").decode.overload('[B').implementation = function(input) {
       var result = this.decode(input);
       console.log("\n[java.util.Base64.Decoder.decode]");
       console.log("Input: " + bytesToHex(input));
       console.log("Result: " + bytesToHex(result));
       return result;
   };
   
   ```
   
   







ArrayList

> 这个其实很少用，但有些时候会遇到，很少很少。。。

```js
var ArrayList = Java.use("java.util.ArrayList");
ArrayList.add.overload("java.lang.Object") = function (item){
    console.log(`Map: ${k}=${v}`);
    if (item && item == "关键词"){
        showStacks(); 
    	console.log(`add: ${item}`);
    }
    return this.add(item);
}
```

```js
ArrayList.add.overload("int", "java.lang.Object") = function (index, item){
    console.log(`Map: ${k}=${v}`);
    if (item && item == "关键词"){
        showStacks(); 
    	console.log(`add: ${item}, index=${index}`);
    }
    return this.add(index, item);
}
```



### String



3.  首尾strip

   这个在java是trim；一般用于用户输入，去除首尾空白字符，用的还是蛮多的

   ```js
   var str = Java.use("java.lang.String");
   str.trim.implementation = function () {
       console.log("str.trim: ",  this);
       printStacks();
       return this.trim();
   }
   ```







### JSONObject

一般用于寻找如何解析响应体

1. 放数据

   ```js
   var jSONObject = Java.use("org.json.JSONObject");
   jSONObject.put.overload('java.lang.String', 'java.lang.Object').implementation = function (a, b) {
       // 这里可以对a b进行过滤
       showStacks();
       console.log("jSONObject.put: ", a, b);
       return this.put(a, b);
   }
   ```

2. 取数据

   optString等价于python 的get； getString找不到会跑异常

   ```js
   jSONObject.getString.implementation = function (a) {
       //var result = Java.cast(a, Java.use("java.util.ArrayList"));
       console.log("jSONObject.getString: ", a);
       var result = this.getString(a);
       console.log("jSONObject.getString result: ", result);
   
       return result;
   }
   
   JSONObject['optString'].overload('java.lang.String').implementation = function (str) {
       if(str === "data"){
           console.log('str', str)
           getStackTraceString();
       }
       let result = this['optString'](str);
       return result;
   };
   ```



   

### StringFactory

```js
// hook string的构造函数  字符串生成的地方例子，new String
var stringFactory = Java.use("java.lang.StringFactory");
stringFactory.newStringFromString.implementation = function (a) {
    var retval = this.newStringFromString(a);
    console.log("stringFactory.newStringFromString: ", retval);
    return retval;
}
stringFactory.newStringFromChars.overload('[C').implementation = function (a) {
    var retval = this.newStringFromChars(a);
    console.log("stringFactory.newStringFromChars: ", retval);
    return retval;
}
```









### StringBuilder

```js
// 字符串拼接
var sb = Java.use("java.lang.StringBuilder");
sb.toString.implementation = function () {
    var retval = this.toString();
    console.log("StringBuilder.toString: ", retval);
    return retval;
}

// 支持多线程 字符串拼接
var sb = Java.use("java.lang.StringBuffer");
sb.toString.implementation = function () {
    var retval = this.toString();
    console.log("StringBuffer.toString: ", retval);
    return retval;
}
```









### Toast

我们用这个方法可以快速定位到界面编写的地方，不过可能需要跟栈找找

```js
var toast = Java.use("android.widget.Toast");
toast.show.implementation = function(){
   showStacks();
   return this.show();
}

```



### TextUtils

这里用于寻找输入框定位之类的，用于硬编码密码爆破和定位检测函数

上面这两个之前，一般都要对输入内容进行判空的，不然java可能报错，所以大概率会用到

```js
var textUtils = Java.use("android.text.TextUtils");
textUtils.isEmpty.implementation = function (a) {
    if (a == "TURJNk1EQTZNREE2TURBNk1EQTZNREE9") { //过滤，不过滤应该挺多的
        console.log("textUtils.isEmpty: ", a);
        showStacks();
    }
    return this.isEmpty(a);
}
```



### EditText

这个一般是上次加密或者检测的时候用到：从输入框中取数据

```js
var editText = Java.use("android.widget.EditText");
editText.getText.overload().implementation = function () {
    var result = this.getText();
    result = Java.cast(result, Java.use("java.lang.CharSequence"));
    console.log("editText.getText: ", result.toString());
    printStacks();
    return result;
}
```





### Log

```js
var log = Java.use("android.util.Log");
log.w.overload('java.lang.String', 'java.lang.String').implementation = function (tag, message) {
    console.log("log.w: ", tag, message);
    return this.w(tag, message);
}
```





### URL

```js
// hook java.net.URL
var URL = Java.use('java.net.URL');
URL.$init.overload('java.lang.String').implementation = function (a) {
    console.log('java.net.URL ' + a)
    this.$init(a)
}

//hook okhttp3 HttpUrl
var Builder = Java.use('okhttp3.Request$Builder');
Builder.url.overload('okhttp3.HttpUrl').implementation = function (a) {
    var res = this.url(a);
    console.log("okhttp3.HttpUrl result: " + res)
    return res;
}
```





### addHeader

```js
var Builder = Java.use("okhttp3.Request$Builder");
Builder["addHeader"].implementation = function (str, str2) {
    console.log("okhttp3.Request$Builder.addHeader key: " + str)
    console.log("okhttp3.Request$Builder.addHeader val: " + str2)
    var result = this["addHeader"](str, str2);
    console.log("okhttp3.Request$Builder.addHeader result: " + result);
    return result;
};
```



### SharedPreferences

```js
// hook内部存储api，打印出存储的数据
var sp = Java.use("android.app.SharedPreferencesImpl$EditorImpl");
sp.putBoolean.overload('java.lang.String', 'boolean').implementation = function(arg1,arg2){
    console.log("[SharedPreferencesImpl ] putBoolean -> key: "+arg1+" = "+arg2);
    return this.putBoolean(arg1,arg2);
}

sp.putString.overload('java.lang.String', 'java.lang.String').implementation = function(arg1,arg2){
    console.log("[SharedPreferencesImpl] putString -> key: "+arg1+" = "+arg2);
    return this.putString(arg1,arg2);
}

sp.putInt.overload('java.lang.String', 'int').implementation = function(arg1,arg2){
    console.log("[SharedPreferencesImpl] putInt -> key: "+arg1+" = "+arg2);
    return this.putInt(arg1,arg2);
}

sp.putFloat.overload('java.lang.String', 'float').implementation = function(arg1,arg2){
    console.log("[SharedPreferencesImpl] putFloat -> key: "+arg1+" = "+arg2);
    return this.putFloat(arg1,arg2);
}

sp.putLong.overload('java.lang.String', 'long').implementation = function(arg1,arg2){
    console.log("[SharedPreferencesImpl] putLong -> key: "+arg1+" = "+arg2);
    return this.putLong(arg1,arg2);
}

// hook应用程序间数据传递的api，打印出传递数据的uri与具体的字段
var content = Java.use("android.content.ContentResolver");
content.insert.overload("android.net.Uri","android.content.ContentValues").implementation = function(arg1,arg2){
    console.log("[ContentResolver] *insert -> Uri: "+arg1+"  Values: "+arg2);
    return this.insert(arg1,arg2);
}

content.delete.overload("android.net.Uri","java.lang.String","[Ljava.lang.String;").implementation = function(arg1,arg2,arg3){
    console.log("[ContentResolver] *delete -> Uri: "+arg1+"\n  -> arg2: "+arg2+"\n  -> arg3: "+arg3);
    return this.delete(arg1,arg2,arg3);
}

content.update.overload('android.net.Uri','android.content.ContentValues','java.lang.String','[Ljava.lang.String;').implementation = function(arg1,arg2,arg3,arg4){
    console.log("[ContentResolver] *update -> Uri: "+arg1+"\n  -> arg2: "+arg2+"\n  -> arg3: "+arg3+"\n  -> arg4: "+arg4);
    return this.update(arg1,arg2,arg3,arg4);
}

content.query.overload('android.net.Uri', '[Ljava.lang.String;', 'android.os.Bundle', 'android.os.CancellationSignal').implementation = function(arg1,arg2,arg3,arg4){
    console.log("[ContentResolver] *query -> Uri: "+arg1+"\n  -> arg2: "+arg2+"\n  -> arg3: "+arg3+"\n  -> arg4: "+arg4);
    return this.query(arg1,arg2,arg3,arg4);
}

content.query.overload('android.net.Uri', '[Ljava.lang.String;', 'java.lang.String', '[Ljava.lang.String;', 'java.lang.String').implementation = function(arg1,arg2,arg3,arg4,arg5){
    console.log("[ContentResolver] *query -> Uri: "+arg1+"\n  -> arg2: "+arg2+"\n  -> arg3: "+arg3+"\n  -> arg4: "+arg4+"\n  -> arg5: "+arg5);
    return this.query(arg1,arg2,arg3,arg4,arg5);
}

content.query.overload('android.net.Uri', '[Ljava.lang.String;', 'java.lang.String', '[Ljava.lang.String;', 'java.lang.String', 'android.os.CancellationSignal').implementation = function(arg1,arg2,arg3,arg4,arg5,arg6){
    console.log("[ContentResolver] *query -> Uri: "+arg1+"\n  -> arg2: "+arg2+"\n  -> arg3: "+arg3+"\n  -> arg4: "+arg4+"\n  -> arg5: "+arg5+"\n arg6: "+arg6);
    return this.query(arg1,arg2,arg3,arg4,arg5,arg6);
}
```



### webview开页面

```js
function WebView() {
    let WebView = Java.use("android.webkit.WebView");
    WebView["postUrl"].implementation = function (str, bArr) {
        var string = java.use('java.lang.String').$new(bArr);
        console.log(`WebView.postUrl is called: str=${str}, string=${string}`);
        this["postUrl"](str, bArr);
    };
    WebView["loadUrl"].overload('java.lang.String').implementation = function (str) {
        console.log(`WebView.loadUrl is called: str=${str}`);
        var s = Java.use('java.lang.String').$new(str);
        var t = Java.use('java.lang.String').$new("https");
        if (s.contains(t)) {
            getStackTraceString();
        }
        this["loadUrl"](str);
    };
    WebView["loadUrl"].overload('java.lang.String', 'java.util.Map').implementation = function (str, map) {
        console.log(`WebView.loadUrl 2is called: str=${str}, map=${map}`);
        this["loadUrl"](str, map);
    };
}
```



### 加壳的hook

加壳之后的hook需要使用classLoader，每一个加载的dex都对应有一个classLoader，然后它们之间互相之间的函数调用，也需要使用到对方的classLoader才可以，没有办法直接使用，我们hook也需要使用到这些，因为这样子才能hook到这个java函数的具体地址，然后变成一个native函数再来进行hook

```js
Java.enumerateClassLoadersSync().forEach(classLoader => {
    try {
        if (classLoader.loadClass("ot2.b")) {
            Java.classFactory.loader = classLoader;
            console.log(classLoader)
            let C82252b = Java.use("ot2.b");
            C82252b["getBdOz"].implementation = function (context) {
                console.log(`C82252b.getBdOz is called: context=${context}`);
                let result = this["getBdOz"](context);
                console.log(`C82252b.getBdOz result=${result}`);
                return result;
            };
        }
    } catch (e) {
        // console.log(e)
    }
})
```





## frida的java层api

```js
// 获取 Java 类的引用
var ExampleClass = Java.use('com.example.ExampleClass');
// 使用 new 关键字来创建 ExampleClass 的一个实例 【造字符串调用getBytes时用的多】
var exampleObject = ExampleClass.$new();
// 使用对象进行一些操作，例如调用其方法
exampleObject.someMethod();

// 强制转换，obj转String
var castValue = Java.cast(obj, Java.use("java.lang.String"))

// 获取对象属性内容，得到的这个对象可以使用.value
// 也可以直接执行函数，是a.函数，而不是a.value.函数
obj.a.value
```





## java层hook相关



### 字节打印utf8

```js
function utf8Bytes(exampleBytes) {
    let StringClass = Java.use("java.lang.String");
    let CharsetClass = Java.use("java.nio.charset.Charset");
    let utf8Charset = CharsetClass.forName("UTF-8");
    return StringClass.$new(exampleBytes, utf8Charset);
}
```



### map打印

```js
function maptoJson(map){
    var Gson = Java.use('com.google.gson.Gson').$new();
    Gson.toJsonTree(map).getAsJsonObject();
}
```



### 打印堆栈

```js
function showJavaStacks() {
    console.log(Java.use('android.util.Log')
        .getStackTraceString(Java.use('java.lang.Throwable')
            .$new()));
}
// 或者
function showJavaStacks() {
	console.log(Java.use("android.util.Log").getStackTraceString(Java.use("java.lang.Exception").$new()));
}
```



### 造数组

```js
var classArray = Java.array("Ljava.lang.Class;", [StringClass.class, StringClass.class]);
```





### 打印方法签名

这个主要是用到 `method` 的 `getName` 拿到函数名 和 `toString` 拿到签名

```js
var methods = clazz.class.getDeclaredMethods();
for (var i = 0; i < methods.length; i++) {
    // 获取方法的名称和签名
    var methodName = methods[i].getName();
    var methodSignature = methods[i].toString(); // toString() 方法会返回方法的签名信息
    console.log("Method: " + methodName + ", Signature: " + methodSignature);
}
```



### 页面控制

```js
function get_activity() {
    Java.perform(function () {
        var ActivityThread = Java.use("android.app.ActivityThread");
        var currentActivityThread = ActivityThread.currentActivityThread();
        var activities = currentActivityThread.mActivities.value;

        var iterator = activities.entrySet().iterator();
        while (iterator.hasNext()) {
            var entry = iterator.next();
            console.log(entry.getClass())
        }
    });
}

function goto_activity() {
    Java.perform(function () {
        var Intent = Java.use("android.content.Intent");
        var ActivityThread = Java.use("android.app.ActivityThread");

        // 获取当前的 Application 上下文
        var currentApplication = ActivityThread.currentApplication();
        var context = currentApplication.getApplicationContext();

        var cpI = Java.use("o.cpI")
        // 构造 Intent
        var intent = Intent.$new(context, cpI.class); // 使用合适的构造器设置 Action 和 Data
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK.value); // 添加 FLAG_ACTIVITY_NEW_TASK
        // 启动目标页面
        console.log("Redirecting to: th.co.truemoney.wallet/o.cpI");
        context.startActivity(intent); // 使用上下文启动 Intent
    });
}
```



### 过滤

1. equals：是否相等
2. ===：是否相等
3. includes ：是否包含子字符串
4. indexOf：返回的是子字符串的索引，找不到就是-1，所以只要>=0就代表找到了





### 主动调用

静态方法直接调用，对象方法需要找到对象或者造一个



1. 静态方法

   ```js
   var ClassName=Java.use("com.zj.wuaipojie.Demo"); 
   ClassName.privateFunc("传参");
   ```

2. 对象方法

   ```js
   var ret = null;
   Java.perform(function () {
       Java.choose("com.zj.wuaipojie.Demo",{    //要hook的类
           onMatch:function(instance){
               ret=instance.privateFunc("aaaaaaa"); //要hook的方法
           },
           onComplete:function(){
               //console.log("result: " + ret);
           }
       });
   })
       //return ret;
   
   ```







## java层加密算法自吐

明文，密文；算法，密钥

1. java层原生加密算法自吐脚本 

   > 网上搜搜了解了解就行了

2. xposed算法助手pro

   都用这个的







## 证书自吐

hook一下keystore.load的输入流，然后下载成文件，再pull下来

导入抓包软件

发包的时候python带着就行













## objection工具

[r0ysue: 实用FRIDA进阶：内存漫游、hook anywhere、抓包](https://www.anquanke.com/post/id/197657)

基本使用

1. 启动

   ```bash
   objection -g 包名 explore
   ```

   

2. 启动就hook

   ```js
   objection -g 包名 explore --startup-command "android hooking watch class 路径.类名"
   ```



3. 查看内存中加载的库【查看so文件】

   ```bash
   memory list modules   -查看内存中加载的库
   ```

   

4. 查看库的导出函数

   > 这一步用ida打开会方便一点

   ```js
   memory list exports so名称 - 查看库的导出函数
   ```

   

5. 查看内存中加载的activity  

   ```bash
   android hooking list activities -
   ```

   

6.  查看内存中加载的services

   ```js
   android hooking list services
   ```

   

7. 强行跳转activity: 启动`activity`或`service`

   这个会有用

   ```bash
   android intent launch_activity 类名
   ```

   

8. 关掉安卓提供的ssl校验

   > 如果软件自己写的，就不行了
   >
   > 这个作用一般了，现在很多框架需要分析so的ssl验证才能过

   ```js
   android sslpinning disable
   ```

   

9. 关闭root检测

   ```bash
   android root disable
   ```

   



### 内存漫游

1. 内存搜刮类实例

    ```smali
    android heap search instances 类名(命令)
    
    Class instance enumeration complete for com.zj.wuaipojie.Demo  
     Hashcode  Class                  toString()
    ---------  ---------------------  -----------------------------
    215120583  com.zj.wuaipojie.Demo  com.zj.wuaipojie.Demo@cd27ac7
    ```

    

2. 调用实例的方法

    ```smali
    android heap execute <handle> getPublicInt(实例的hashcode+方法名)
    
    如果是带参数的方法，则需要进入编辑器环境  
    android heap evaluate <handle>  
    console.log(clazz.a("吾爱破解"));
    按住esc+enter触发
    ```

    

3. 列出内存中所有的类(结果比静态分析的更准确)

    ```nginx
    android hooking list classes 
    
    tw.idv.palatis.xappdebug.MainApplication
    tw.idv.palatis.xappdebug.xposed.HookMain
    tw.idv.palatis.xappdebug.xposed.HookMain$a
    tw.idv.palatis.xappdebug.xposed.HookMain$b
    tw.idv.palatis.xappdebug.xposed.HookMain$c
    tw.idv.palatis.xappdebug.xposed.HookMain$d
    tw.idv.palatis.xappdebug.xposed.HookSelf
    u
    v
    void
    w
    xposed.dummy.XResourcesSuperClass
    xposed.dummy.XTypedArraySuperClass
    
    Found 10798 classes
    ```

    

4. 在内存中所有已加载的类中搜索包含特定关键词的类

    ```nginx
     复制代码 隐藏代码
    android hooking search classes wuaipojie
    Note that Java classes are only loaded when they are used, so if the expected class has not been found, it might not have been loaded yet.
    com.zj.wuaipojie.Demo
    com.zj.wuaipojie.Demo$Animal
    com.zj.wuaipojie.Demo$Companion
    com.zj.wuaipojie.Demo$InnerClass
    com.zj.wuaipojie.Demo$test$1
    com.zj.wuaipojie.MainApplication
    com.zj.wuaipojie.databinding.ActivityMainBinding
    ... 
    
    Found 38 classes
    ```

    

5. 在内存中所有已加载的类的方法中搜索包含特定关键词的方法(一般不建议使用，特别耗时，还可能崩溃)

  ```nginx
  android hooking search methods 关键方法名 -
  ```

6. 内存漫游类中的所有方法

   android hooking list class_methods 类名

   ```js
    android hooking list class_methods com.zj.wuaipojie.ui.ChallengeSixth
    private static final void com.zj.wuaipojie.ui.ChallengeSixth.onCreate$lambda-.String)
    public final void com.zj.wuaipojie.ui.ChallengeSixth.toastPrint(java.lang.String)
   
   ```

   



### Hook

1. hook类的所有方法

   ```cpp
   android hooking watch class 类名
   ```

2. hook方法的参数、返回值和调用栈

   ```perl
   android hooking watch class_method 类名.方法名 --dump-args --dump-return --dump-backtrace
   ```

3. hook 类的构造方法

   ```nginx
   android hooking watch class_method 类名.$init
   ```

4. hook 方法的所有重载

   ```mipsasm
   android hooking watch class_method 类名.方法名
   ```







## frida进阶api2

### Process

`Process` 对象代表当前被Hook的进程，能获取进程的信息，枚举模块，枚举范围等

| `Process.id`                   | 返回附加目标进程的 `PID`                                     |
| ------------------------------ | ------------------------------------------------------------ |
| `Process.isDebuggerAttached()` | 检测当前是否对目标程序已经附加                               |
| `Process.enumerateModules()`   | 枚举当前加载的模块，返回模块对象的数组                       |
| `Process.enumerateThreads()`   | 枚举当前所有的线程，返回包含 `id`, `state`, `context` 等属性的对象数组 |



### Module

`Module` 对象代表一个加载到进程的模块

> (例如，在 Windows 上的 DLL，或在 Linux/Android 上的 .so 文件)



**能查询模块的信息，如模块的基址、名称、导入/导出的函数等**

| API                                                          | 含义                                     |
| :----------------------------------------------------------- | :--------------------------------------- |
| `Module.load()`                                              | 加载指定so文件，返回一个Module对象       |
| `enumerateImports()`                                         | 枚举所有Import库函数，返回Module数组对象 |
| `enumerateExports()`                                         | 枚举所有Export库函数，返回Module数组对象 |
| `enumerateSymbols()`                                         | 枚举所有Symbol库函数，返回Module数组对象 |
| `Module.findExportByName(exportName)、Module.getExportByName(exportName)` | 寻找指定so中export库中的函数地址         |
| `Module.findBaseAddress(name)、Module.getBaseAddress(name)`  | **返回so的基地址**                       |



### Memory

`Memory`是一个工具对象，提供直接读取和修改进程内存的功能，能够读取特定地址的值、写入数据、分配内存等



| 方法                      | 功能                                                        |
| :------------------------ | :---------------------------------------------------------- |
| `Memory.copy()`           | 复制内存                                                    |
| `Memory.scan()`           | 搜索内存中特定模式的数据                                    |
| `Memory.scanSync()`       | 同上，但返回多个匹配的数据                                  |
| `Memory.alloc()`          | 在目标进程的堆上申请指定大小的内存，返回一个`NativePointer` |
| `Memory.writeByteArray()` | 将字节数组写入一个指定内存                                  |
| `Memory.readByteArray`    | 读取内存                                                    |



```js
console.log(soAddr);
if(soAddr != null){
    //读取指定地址的字符串 dump指定内存
    //console.log(soAddr.add(0x2C00).readCString());
    //console.log(hexdump(soAddr.add(0x2C00)));

    //读内存
    //var strByte = soAddr.add(0x2C00).readByteArray(16); 
    //console.log(strByte);

    //写内存
    //soAddr.add(0x2C00).writeByteArray(stringToBytes("xiaojianbang")); 
    //读取指定地址的字符串 dump指定内存
    //console.log(hexdump(soAddr.add(0x2C00)));  

    //var bytes = Memory.readByteArray(soAddr.add(0x2C00), 16); //原先API
    //console.log(bytes);

}

```









### 枚举导入导出表、符号表

```js
Java.perform(function(){
    // 打印导入表：ida中的imports
    var imports = Module.enumerateImports("lib52pojie.so");
    for(var i =0; i < imports.length;i++){
        if(imports[i].name == "vip"){
            // 得到类型，名字，地址
            console.log(JSON.stringify(imports[i])); //通过JSON.stringify打印object数据
            // console.log(imports[i].address);
        }
    }
    // 打印导出表：ida中的exports
    var exports = Module.enumerateExports("lib52pojie.so");
    for(var i =0; i < exports.length;i++){
        console.log(JSON.stringify(exports[i]));
    }
    // 符号表: ida中的function name
    var symbols = Module.enumerateSymbols("libxiaojanbang.so");
    for(var i =0; i < symbols.length;i++){
        console.log(JSON.stringify(symbols[i]));
    }
})
```







## so层hook相关

### 函数hook

- 导出函数有：根据名字&偏移

  > 注意名称粉碎； 以汇编中的为准

  ```js
  var func_addr = Module.findExportByName("libxiaojianbang.so", "函数名字");
  ```

  

- 导出函数没有：so基地址+函数偏移

  > thmub汇编需要地址额外+1；arm汇编不用加
  >
  > ida设置optcode长度为4，arm64全是4个一组；2，4混搭是thumb

  ```js
  // so基地址
  var moduleAddr1 = Process.findModuleByName("lib52pojie.so").base;  
  var moduleAddr2 = Process.getModuleByName("lib52pojie.so").base;  
  var moduleAddr3 = Module.findBaseAddress("lib52pojie.so");
  
  // arm汇编
  var helloAddr = moduleAddr3.add(0x369c8);
  // thumb汇编
  var helloAddr = moduleAddr3.add(0x369c8 + 1);
  ```

  



函数地址计算:

1. 安卓里一般32 位的 so 中都是`thumb`指令，64 位的 so 中都是`arm`指令
2. 通过IDA里的opcode bytes来判断，arm 指令为 4 个字节(options -> general -> Number of opcode bytes (non-graph)  输入4)
3. thumb 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移 + 1
   arm 指令，函数地址计算方式： so 基址 + 函数在 so 中的偏移







### 参数打印

- 整数型、布尔值类型、char类型

```js
Java.perform(function(){
    //根据导出函数名打印地址
    var helloAddr = Module.findExportByName("lib52pojie.so","Java_com_zj_wuaipojie_util_SecurityUtil_checkVip");
    console.log(helloAddr);
    if(helloAddr != null){
        console.log("没找到hello函数");
        return;
    }
    //Interceptor.attach是Frida里的一个拦截器
    Interceptor.attach(helloAddr,{
        //onEnter里可以打印和修改参数
        onEnter: function(args){  //args传入参数
            console.log(args[0]);  //打印第一个参数的值
            console.log(this.context.x1);  // 打印寄存器内容
            console.log(args[1].toInt32()); //toInt32()转十进制
            console.log(args[2].readCString()); //读取字符串 char类型
            console.log(hexdump(args[2])); //内存dump, hexdump的第二个函数可以指定dump长度
        },
        //onLeave里可以打印和修改返回值
        onLeave: function(retval){  //retval返回值
            console.log(retval);
            console.log("retval",retval.toInt32());
        }
    })
})

```



- 字符串类型

```js
Java.perform(function (){
    //根据导出函数名打印地址
    var helloAddr = Module.findExportByName("lib52pojie.so","Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel");
    if(helloAddr != null){
        console.log("没找到hello函数");
        return;
    }
    // hook：函数拦截
    Interceptor.attach(helloAddr,{
        //onEnter里可以打印和修改参数
        onEnter: function(args){  //args传入参数
            // 方法一: 转为Java的字符串
            var jString = Java.cast(args[2], Java.use('java.lang.String'));
            console.log("参数:", jString.toString());
            // 方法二：调用jni方法打印
            var JNIEnv = Java.vm.getEnv(); // tryGetEnv
            var originalStrPtr = JNIEnv.getStringUtfChars(args[2], null).readCString();        
            console.log("参数:", originalStrPtr);                                
        },
        //onLeave里可以打印和修改返回值
        onLeave: function(retval){  //retval返回值
            var returnedJString = Java.cast(retval, Java.use('java.lang.String'));
            console.log("返回值:", returnedJString.toString());
        }
    })
})

```





### 打印调用栈

```js
function stackTraceNativeHere(isLog){
    var backtrace = Thread.backtrace(this.context, Backtracer.ACCURATE)
    .map(DebugSymbol.fromAddress)
    .join("\n\t");
    console.log(backtrace)
}

function showSoStacks(this_obj) {
    console.log(`Call Stack:\n${Thread.backtrace(this_obj.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\n')}`);
}

// 用的时候要在函数内部 showSoStacks(this)
```







### jni函数

[frida-java-bridge](https://github.com/frida/frida-java-bridge)

jnihook三件套：

[libart的hook三件套](https://github.com/lasting-yang/frida_hook_libart)

- hook

  ```js
  //Hook libart 来Hook jni相关函数
  function hookTest10(){
      var artSym = Module.enumerateSymbols("libart.so");
      var NewStringUTFAddr = null;
      for(var i = 0; i < artSym.length; i++){
          // 不包含checkjni，并且有newstringutf，这样拿到的是art::JNI::NewStringUTF
          if(artSym[i].name.indexOf("CheckJNI") == -1 && artSym[i].name.indexOf("NewStringUTF") != -1){
              console.log(JSON.stringify(artSym[i]));
              NewStringUTFAddr = artSym[i].address;
          }
      };
  
      if(NewStringUTFAddr != null){
          Interceptor.attach(NewStringUTFAddr,{
              onEnter: function(args){
                  // 第一个是env，第二个是
                  console.log(args[1].readCString());
              },
              onLeave: function(retval){
  
              }
          });
      }
  }
  ```
  
  



- **主动调用**

  > 比如：
  >
  > - 进入的时候我们把jstr转cstr
  > - 退出的时候我们主动cstr转为jstr
  
  ```js
  //主动调用JNI函数
  function hookTest8(){
      var funcAddr = Module.findExportByName("libxiaojianbang.so", "Java_com_xiaojianbang_app_NativeHelper_helloFromC");
      console.log(funcAddr);
      if(funcAddr != null){
          Interceptor.attach(funcAddr,{
              onEnter: function(args){
  
              },
              onLeave: function(retval){
                  var env = Java.vm.tryGetEnv();
                  var jstr = env.newStringUtf("bbs.125.la");  //主动调用jni函数 cstr转jstr
                  retval.replace(jstr);
  
                  var cstr = env.getStringUtfChars(jstr); //主动调用 jstr转cstr
                  console.log(cstr.readCString());
                  console.log(hexdump(cstr));
            }
          });
      }
  }
  ```
  
  



### so层主动调用

```js
//so层主动调用任意函数
function hookTest11(){
    Java.perform(function(){
        //拿到函数地址
        var funcAddr = Module.findBaseAddress("libxiaojianbang.so").add(0x23F4);
        //声明函数指针
        var func = new NativeFunction(funcAddr, "pointer", ['pointer', 'pointer']);
        var env = Java.vm.tryGetEnv();
        console.log("env: ", JSON.stringify(env));
        if(env != null){
            var jstr = env.newStringUtf("xiaojianbang is very good!!!");
            var cstr = func(env, jstr);
            console.log(cstr.readCString());
            console.log(hexdump(cstr));
        }
    });
}
```





native函数: frida官方文档 https://frida.re/docs/javascript-api/#nativefunction

```js
var funcAddr = Module.findBaseAddress("lib52pojie.so").add(0x1054C);
//声明函数指针
//NativeFunction的第一个参数是地址，第二个参数是返回值类型，第三个[]里的是传入的参数类型(有几个就填几个)
var aesAddr = new NativeFunction(funcAddr , 'pointer', ['pointer', 'pointer']);
var encry_text = Memory.allocUtf8String("OOmGYpk6s0qPSXEPp4X31g==");    //开辟一个指针存放字符串       
var key = Memory.allocUtf8String('wuaipojie0123456'); 
console.log(aesAddr(encry_text ,key).readCString());

```









### 延迟hook

原理：

- 安卓中是dlopen加载so【高版本是dlopen_ext】；

- 我们只需要检测so加载了再hook就行

这里请看下面的系统库





### dump内存

```js
var so_addr = Module.findExportByName("lib52pojie.so");

// 读内存
var strByte = so_addr.add(0x2c00).readByteArray(16);
console.log(strByte);

// 写内存
so_addr.add(0x2c00).writeByteArray(stringToBytes("xiaojianbang"));
console.log(hexdump(so_addr.add(0x2c00)));

// 也可以用Memory类的api
```





### so层函数hook修改

#### 整数型修改

> 返回指针就行，套个ptr；返回值替换用replace；修改参数用ptr

```js
Java.perform(function(){
    //根据导出函数名打印地址
    var helloAddr = Module.findExportByName("lib52pojie.so","Java_com_zj_wuaipojie_util_SecurityUtil_checkVip");
    console.log(helloAddr);
    if(helloAddr != null){
        console.log("没找到hello函数");
        return;
    }
    Interceptor.attach(helloAddr,{
        onEnter: function(args){  //args参数
            args[0] = ptr(1000); //第一个参数修改为整数 1000，先转为指针再赋值
            console.log(args[0]);
        },
        onLeave: function(retval){  //retval返回值
            retval.replace(20000);  //返回值修改
            console.log("retval",retval.toInt32());
        }
    })
})

```





#### 字符串类型修改

```js
function hookTest2(){
Java.perform(function(){
    //根据导出函数名打印地址
    var helloAddr = Module.findExportByName("lib52pojie.so","Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel");
    if(helloAddr != null){
        console.log("没找到hello函数");
        return;
    }
    Interceptor.attach(helloAddr,{
        //onEnter里可以打印和修改参数
        onEnter: function(args){  //args传入参数
            var JNIEnv = Java.vm.getEnv();
            var originalStrPtr = JNIEnv.getStringUtfChars(args[2], null).readCString();        
            console.log("参数:", originalStrPtr);
            var modifiedContent = "至尊";
            var newJString = JNIEnv.newStringUtf(modifiedContent);
            args[2] = newJString;                                
        },
        //onLeave里可以打印和修改返回值
        onLeave: function(retval){  //retval返回值
            var returnedJString = Java.cast(retval, Java.use('java.lang.String'));
            console.log("返回值:", returnedJString.toString());
            var JNIEnv = Java.vm.getEnv();
            var modifiedContent = "无敌";
            var newJString = JNIEnv.newStringUtf(modifiedContent);
            retval.replace(newJString);
        }
    })
})
}
```



#### 数组

```js
function hookTest2(){
Java.perform(function(){
    //根据导出函数名打印地址
    var helloAddr = Module.findExportByName("lib52pojie.so","Java_com_zj_wuaipojie_util_SecurityUtil_vipLevel");
    if(helloAddr != null){
        console.log("没找到hello函数");
        return;
    }
    Interceptor.attach(helloAddr,{
        //onEnter里可以打印和修改参数
        onEnter: function(args){  //args传入参数
            this.arg1 = args[1];
        },
        //onLeave里可以打印和修改返回值
        onLeave: function(retval){  //retval返回值
            ptr(this.args1).writeByteArray(hexToBytes("0123456789adcdef0123456789adcdef"));
            console.log(hexdump(this.arg1));
        }
    })
})
}
```





















## Frida写文件

```js
//一般写在app的私有目录里，不然会报错:failed to open file (Permission denied)(实际上就是权限不足)
var file_path = "/data/user/0/com.zj.wuaipojie/test.txt";
var file_handle = new File(file_path, "wb");
if (file_handle && file_handle != null) {
        file_handle.write(data); //写入数据
        file_handle.flush(); //刷新
        file_handle.close(); //关闭
}
```









## Frida_inlineHook与读写汇编

什么是inlinehook？
Inline hook（内联钩子）是一种在程序运行时修改函数执行流程的技术。**它通过修改函数的原始代码，将目标函数的执行路径重定向到自定义的代码段，从而实现对目标函数的拦截和修改。**
简单来说就是可以对任意地址的指令进行hook读写操作

> Frida的inlinehook不是太稳定，崩溃是基操，另外新版的frida兼容性会比较好



常见inlinehook框架:

- [Android-Inline-Hook](https://github.com/ele7enxxh/Android-Inline-Hook)
- [whale](https://github.com/asLody/whale)
- [Dobby](https://github.com/jmpews/Dobby)
- [substrate](http://www.cydiasubstrate.com/)





```js
function inline_hook() {
    var soAddr = Module.findBaseAddress("lib52pojie.so");
    if (!soAddr){
        console.log("can't find so!");
    }
    // 修改指定内存器值
    var func_addr = soAddr.add(0x10428);
    Java.perform(function () {
        Interceptor.attach(func_addr, {
            onEnter: function (args) {
                console.log(this.context.x22); //注意此时就没有args概念了
                this.context.x22 = ptr(1); //赋值方法参考上一节课
            },
            onLeave: function (retval) {
            }
    })
}

```



```js
//inlineHook与寄存器Hook
function hookTest14(){
    var soAddr = Module.findBaseAddress("libxiaojianbang.so");
    console.log(soAddr);
    var sub_2894 = soAddr.add(0x2894); //函数地址计算 thumb+1 ARM不加
    console.log(sub_2894);
    if(sub_2894 != null){
        Interceptor.attach(sub_2894,{
            onEnter: function(){
                console.log(this.context.x0.toInt32());
                this.context.x0 = 0x1000;
                console.log(this.context.x0.toInt32());
            },
            onLeave: function(){

            }
        });
    }

    var sub_2858 = soAddr.add(0x2858); //函数地址计算 thumb+1 ARM不加
    console.log(sub_2858);
    if(sub_2858 != null){
        Interceptor.attach(sub_2858,{
            onEnter: function(){
                console.log(this.context.x1);
                this.context.x1 = soAddr.add(0x2C35);
                console.log(this.context.x1);
            },
            onLeave: function(){

            }
        });
    }
}
```







### 地址指令转汇编

```js
var soAddr = Module.findBaseAddress("lib52pojie.so");
var codeAddr = Instruction.parse(soAddr.add(0x10428));
console.log(codeAddr.toString());
```





### arm2hex

arm2hex: https://armconverter.com/



```js
var soAddr = Module.findBaseAddress("lib52pojie.so");
var codeAddr = soAddr.add(0x10428);
Memory.patchCode(codeAddr, 4, function(code) {
const writer = new Arm64Writer(code, { pc: codeAddr });
writer.putBytes(hexToBytes("20008052"));
writer.flush();
});
function hexToBytes(str) {
var pos = 0;
var len = str.length;
if (len % 2 != 0) {
    return null;
}
len /= 2;
var hexA = new Array();
for (var i = 0; i < len; i++) {
    var s = str.substr(pos, 2);
    var v = parseInt(s, 16);
    hexA.push(v);
    pos += 2;
}
return hexA;
}
```







# ida使用











# trace技术

| jnitrace          | 老牌，经典，信息全，携带方便                                 | [jnitrace](https://github.com/chame1eon/jnitrace)            |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| jnitrace-engine   | 基于jnitrace，可定制化                                       | [jnitrace-engine](https://github.com/chame1eon/jnitrace-engine) |
| jtrace            | 定制方便，信息全面，直接在_agent.js或者_agent_stable.js 里面加自己的逻辑就行 | [jtrace](https://github.com/SeeFlowerX/jtrace)               |
| hook_art.js       | 可提供jni trace，可以灵活的增加你需要hook的函数              | [hook_art.js](https://github.com/lasting-yang/frida_hook_libart) |
| JNI-Frida-Hook    | 函数名已定义，方便定位                                       | [JNI-Frida-Hook](https://github.com/Areizen/JNI-Frida-Hook)  |
| findhash          | ida插件，可用于检测加解密函数，也可作为Native Trace库        | [findhash](https://github.com/Pr0214/findhash)               |
| Stalker           | frida官方提供的代码跟踪引擎，可以在Native层方法级别，块级别，指令级别实现代码修改，代码跟踪 | [Stalker](https://frida.re/docs/stalker/)                    |
| sktrace           | 类似 ida 指令 trace 功能                                     | [sktrace](https://github.com/bmax121/sktrace)                |
| frida-qbdi-tracer | 速度比frida stalker快，免补环境                              | [frida-qbdi-tracer](https://github.com/lasting-yang/frida-qbdi-tracer) |



## frida-trace

frida-trace 可以一次性监控一堆函数地址。还能打印出比较漂亮的树状图，不仅可以显示调用流程，还能显示调用层次。并且贴心的把不同线程调用结果用不同的颜色区分开了。[官方文档](https://frida.re/docs/frida-trace/)



大佬整理的文档: [frida-trace](https://crifan.github.io/reverse_debug_frida/website/use_frida/frida_trace/)



```bash
# 附加当前进程并追踪lib52pojie.so里的所有Java_开头的jni导出函数
frida-trace -U -F -I "lib52pojie.so" -i "Java_" 
```

- `-i` / `-a`: 跟踪 C 函数或 so 库中的函数。
  PS:-a 包含模块+偏移跟踪，一般用于追踪未导出函数，例子：-a "lib52pojie.so!0x4793c"

包含/排除模块或函数：

- `-I` : 包含指定模块。
- `-X` : 排除指定模块。

Java 方法跟踪：

- `-j JAVA_METHOD`: 包含 Java 方法。
- `-J JAVA_METHOD`: 排除 Java 方法。

附加方式:

- `-f`:通过 spwan 方式启动
- `-F`:通过 attach 方式附加当前进程

日志输出:
`-o`:日志输出到文件





## jnitrace

```bash
pip install jnitrace
```





使用：

`-l libnative-lib.so`- 用于指定要跟踪的库
`-m <spawn|attach>`- 用于指定要使用的 Frida 附加机制
`-i <regex>`- 用于指定应跟踪的方法名称，例如，`-i Get -i RegisterNatives`将仅包含名称中包含 Get 或 RegisterNatives 的 JNI 方法
`-e <regex>`- 用于指定跟踪中应忽略的方法名称，例如，`-e ^Find -e GetEnv`将从结果中排除所有以 Find 开头或包含 GetEnv 的 JNI 方法名称
`-I <string>`- 用于指定应跟踪的库的导出
`-E <string>`用于指定不应跟踪的库的导出
`-o path/output.json`- 用于指定`jnitrace`存储所有跟踪数据的输出路径

```bash
jnitrace -m attach -l lib52pojie.so com.zj.wuaipojie -o trace.json //attach模式附加52pojie.so并输出日志
```









## sktrace

```bash
python sktrace.py -m attach -l lib52pojie.so -i 0x103B4 com.zj.wuaipojie
```













## stalker













# hook安卓底层

## dlopen

```js
var android_dlopen_ext = Module.findExportByName(null, "android_dlopen_ext");
Interceptor.attach(android_dlopen_ext, {
    onEnter: function (args) {
        var so_path = args[0].readCString();
        if (so_path.indexOf("lib52pojie.so") >= 0) {
            console.log("loading: ", so_path)
            this.call_hook = true;
        }
    }, onLeave: function (retval) {
        if (this.call_hook) {
            // 退出的时候才加载完
            hookTest2();
   		}
    }
});
```







## libart

`libart.so`: 在 Android 5.0（Lollipop）及更高版本中，`libart.so` 是 Android 运行时（ART，Android Runtime）的核心组件，它取代了之前的 Dalvik 虚拟机。可以在 `libart.so` 里找到 JNI 相关的实现。
PS:在高于安卓10的系统里，so的路径是/apex/com.android.runtime/lib64/libart.so，低于10的则在system/lib64/libart.so



[libart的hook三件套](https://github.com/lasting-yang/frida_hook_libart)



| 函数名称                                                     | 参数                                                         | 描述                                                         | 返回值                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------------------------------------- |
| `RegisterNatives`                                            | `JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods` | 反注册类的本地方法。类将返回到链接或注册了本地方法函数前的状态。该函数不应在本地代码中使用。相反，它可以为某些程序提供一种重新加载和重新链接本地库的途径。 | 成功时返回0；失败时返回负数              |
| `GetStringUTFChars`                                          | `JNIEnv*env, jstring string, jboolean *isCopy`               | 通过JNIEnv接口指针调用，它将一个代表着Java虚拟机中的字符串jstring引用，转换成为一个UTF-8形式的C字符串 | -                                        |
| `NewStringUTF`                                               | `JNIEnv *env, const char *bytes`                             | 以字节为单位返回字符串的 UTF-8 长度                          | 返回字符串的长度                         |
| `FindClass`                                                  | `JNIEnv *env, const char *name`                              | 通过对象获取这个类。该函数比较简单，唯一注意的是对象不能为NULL，否则获取的class肯定返回也为NULL。 | -                                        |
| `GetMethodID`                                                | `JNIEnv *env, jclass clazz, const char *name, const char *sig` | 返回类或接口实例（非静态）方法的方法 ID。方法可在某个 clazz 的超类中定义，也可从 clazz 继承。GetMethodID() 可使未初始化的类初始化。 | 方法ID，如果找不到指定的方法，则为NULL   |
| `GetStaticMethodID`                                          | `JNIEnv *env, jclass clazz, const char *name, const char *sig` | 获取类对象的静态方法ID                                       | 属性ID对象。如果操作失败，则返回NULL     |
| `GetFieldID`                                                 | `JNIEnv *env, jclass clazz, const char *name, const char *sig` | 回Java类（非静态）域的属性ID。该域由其名称及签名指定。访问器函数的Get<type>Field 及 Set<type>Field系列使用域 ID 检索对象域。GetFieldID() 不能用于获取数组的长度域。应使用GetArrayLength()。 | -                                        |
| `GetStaticFieldID`                                           | `JNIEnv *env,jclass clazz, const char *name, const char *sig` | 获取类的静态域ID方法                                         | -                                        |
| `Call<type>Method`, `Call<type>MethodA`, `Call<type>MethodV` | `JNIEnv *env, jobject obj, jmethodID methodID, .../jvalue *args/va_list args` | 这三个操作的方法用于从本地方法调用Java 实例方法。它们的差别仅在于向其所调用的方法传递参数时所用的机制。 | NativeType，具体的返回值取决于调用的类型 |









### JNI_OnLoad流程

![1748738061510](assets/1748738061510.png)







### jni函数hook

[hook_art.js](https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_art.js)

hook art中的jni函数并且有打印参数和返回值

> 使用之前记得先加上过滤的so名称，另外高版本的系统也需要在脚本68行的过滤修改成`_ZN3art3JNI`(最好是加载libart.so查看一下)，这个脚本包含了hook_RegisterNatives.js的内容(但不太稳定，做个了解即可)









### 动态注册函数



hook_RegisterNatives.js：hook打印动态注册的函数



[hook_RegisterNatives.js](https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_art.js)









2. 带过滤的hook动态注册

   ```js
   // 获取 RegisterNatives 函数的内存地址，并赋值给addrRegisterNatives。
   var addrRegisterNatives = null;
   
   // 列举 libart.so 中的所有导出函数（成员列表）
   var symbols = Module.enumerateSymbolsSync("libart.so");
   
   
   for (var i = 0; i < symbols.length; i++) {
       var symbol = symbols[i];
   
       // console.log(symbol.name)
       //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi
       if (symbol.name.indexOf("art") >= 0 &&
           symbol.name.indexOf("JNI") >= 0 &&
           symbol.name.indexOf("RegisterNatives") >= 0 &&
           symbol.name.indexOf("CheckJNI") < 0) {
   
           addrRegisterNatives = symbol.address;
           console.log("RegisterNatives is at ", symbol.address, symbol.name);
           break
       }
   }
   
   
   if (addrRegisterNatives) {
       // RegisterNatives(env, 类型, Java和C的对应关系,个数)
       Interceptor.attach(addrRegisterNatives, {
           onEnter: function (args) {
               var env = args[0];        // jni对象
               var java_class = args[1]; // 类
               var class_name = Java.vm.tryGetEnv().getClassName(java_class);
               var taget_class = "com.faloo.util.EncryptUtil";
   
               // if (class_name === taget_class) {
               //只找我们自己想要类中的动态注册关系
               console.log("\n[RegisterNatives] method_count:", args[3]);
               var methods_ptr = ptr(args[2]);
               var method_count = parseInt(args[3]);
   
               for (var i = 0; i < method_count; i++) {
                   // Java中函数名字的
                   var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));
                   // 参数和返回值类型
                   var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));
                   // C中的函数内存地址
                   var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));
   
   
                   var name = Memory.readCString(name_ptr);
                   var sig = Memory.readCString(sig_ptr);
   
                   var find_module = Process.findModuleByAddress(fnPtr_ptr);
                   // 地址、偏移量、基地址
                   var offset = ptr(fnPtr_ptr).sub(find_module.base);
   
                   console.log("name:", name, "name:", sig, "module_name:", find_module.name, "offset:", offset, "class: ", class_name);
                   // console.log("name:", name, "name:", sig, "offset:", offset);
   
                   // }
   
               }
           }
       });
   }
   // frida -U -f tv.danmaku.bili -l 3.动态注册hook_so.js
   
   ```

   



### 打印java函数调用so函数，调用栈



[hook_artmethod.js]([hook_art.js](https://github.com/lasting-yang/frida_hook_libart/blob/master/hook_artmethod.js))









## libc

`libc.so`: 这是一个标准的 C 语言库，用于提供基本的系统调用和功能，如文件操作、字符串处理、内存分配等。在Android系统中，`libc` 是最基础的库之一。



> 过frida检测：strstr，strcmp等等
>
> 寻找签名校验&ssl证书：fopen检测加载的文件
>
> 过frida检测线程：pthread_create
>
> 抓包：sockect，recv

| 类别             | 函数名称                | 参数                                                         | 描述                                        |
| :--------------- | :---------------------- | :----------------------------------------------------------- | :------------------------------------------ |
| 字符串类操作     | strcpy                  | `char *dest, const char *src`                                | 将字符串 src 复制到 dest                    |
|                  | strcat                  | `char *dest, const char *src`                                | 将字符串 src 连接到 dest 的末尾             |
|                  | strlen                  | `const char *str`                                            | 返回 str 的长度                             |
|                  | strcmp                  | `const char *str1, const char *str2`                         | 比较两个字符串                              |
| 文件类操作       | fopen                   | `const char *filename, const char *mode`                     | 打开文件                                    |
|                  | fread                   | `void *ptr, size_t size, size_t count, FILE *stream`         | 从文件读取数据                              |
|                  | fwrite                  | `const void *ptr, size_t size, size_t count, FILE *stream`   | 写入数据到文件                              |
|                  | fclose                  | `FILE *stream`                                               | 关闭文件                                    |
| 网络IO类操作     | socket                  | `int domain, int type, int protocol`                         | 创建网络套接字                              |
|                  | connect                 | `int sockfd, const struct sockaddr *addr, socklen_t addrlen` | 连接套接字                                  |
|                  | recv                    | `int sockfd, void *buf, size_t len, int flags`               | 从套接字接收数据                            |
|                  | send                    | `int sockfd, const void *buf, size_t len, int flags`         | 通过套接字发送数据                          |
| 线程类操作       | pthread_create          | `pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg` | 创建线程                                    |
| 进程控制操作     | kill                    | `pid_t pid, int sig`                                         | 向指定进程发送信号                          |
| 系统属性查询操作 | `__system_property_get` | `const char *name, char *value`                              | 从Android系统属性服务中读取指定属性的值     |
|                  | uname                   | `struct utsname *buf`                                        | 获取当前系统的名称、版本和其他相关信息      |
|                  | sysconf                 | `int name`                                                   | 获取运行时系统的配置信息，如CPU数量、页大小 |



### 定位谁杀死的进程

```js
function replaceKILL() {
    // 查找libc.so库中kill函数的地址
    var kill_addr = Module.findExportByName("libc.so", "kill");
    // 使用Interceptor.replace来替换kill函数
    Interceptor.replace(kill_addr, new NativeCallback(function (arg0, arg1) {
        // 当kill函数被调用时，打印第一个参数（通常是进程ID）
        console.log("arg0=> ", arg0);
        // 打印第二个参数（通常是发送的信号）
        console.log("arg1=> ", arg1);
        // 打印调用kill函数的堆栈跟踪信息
        console.log('libc.so!kill called from:\n' +
            Thread.backtrace(this.context, Backtracer.ACCURATE)
            .map(DebugSymbol.fromAddress).join('\n') + '\n');
    }, "int", ["int", "int"]))
}

```



### 定位线程创建

```js
function hook_pthread_create(){
    //hook反调试
    var pthread_create_addr = Module.findExportByName("libc.so", "pthread_create");
    console.log("pthread_create_addr: ", pthread_create_addr);
    Interceptor.attach(pthread_create_addr,{
        onEnter:function(args){
            console.log(args[0], args[1], args[2], args[4]);
        },onLeave:function(retval){
            console.log("retval is =>",retval)
        }
    })
}
```



### 寻找检测点：strstr、strcmp

```js
function hook_strcmp() {
    var pt_strcmp = Module.findExportByName("libc.so", 'strcmp');
    Interceptor.attach(pt_strcmp, {
        onEnter: function (args) {
            var str1 = args[0].readCString();
            var str2 = args[1].readCString();
            if (str2.indexOf("hh") !== -1) {
                console.log("strcmp-->", str1, str2);
                this.printStack = true;
            }
        }, onLeave: function (retval) {
            if (this.printStack) { 
                var stack = Thread.backtrace(this.context, Backtracer.ACCURATE)
                    .map(DebugSymbol.fromAddress).join("\n");
                console.log("Stack trace:\n" + stack);
            }
        }
    })
}

```



### 监测写文件

```js
//Hook libc 写文件
function hookTest13() {

    var addr_fopen = Module.findExportByName("libc.so", "fopen");
    var addr_fputs = Module.findExportByName("libc.so", "fputs");
    var addr_fclose = Module.findExportByName("libc.so", "fclose");

    console.log("addr_fopen:", addr_fopen, "addr_fputs:", addr_fputs, "addr_fclose:", addr_fclose);
    var fopen = new NativeFunction(addr_fopen, "pointer", ["pointer", "pointer"]);
    var fputs = new NativeFunction(addr_fputs, "int", ["pointer", "pointer"]);
    var fclose = new NativeFunction(addr_fclose, "int", ["pointer"]);

    var filename = Memory.allocUtf8String("/sdcard/xiaojianbang.txt");
    var open_mode = Memory.allocUtf8String("w");
    var file = fopen(filename, open_mode);
    console.log("fopen:", file);

    var buffer = Memory.allocUtf8String("bbs.125.la\n");
    var retval = fputs(buffer, file);
    console.log("fputs:", retval);

    fclose(file);

}
```





## libdl

`libdl.so`是一个处理动态链接和加载的标准库，它提供了`dlopen`、`dlclose`、`dlsym`等函数，用于在运行时动态地加载和使用共享库

| 类别           | 函数名称 | 参数                               | 描述                       |
| :------------- | :------- | :--------------------------------- | :------------------------- |
| 动态链接库操作 | dlopen   | `const char *filename, int flag`   | 打开动态链接库文件         |
|                | dlsym    | `void *handle, const char *symbol` | 从动态链接库中获取符号地址 |

### 获取jni静态注册方法地址： dlsym

```js
function hook_dlsym() {
    var dlsymAddr = Module.findExportByName("libdl.so", "dlsym");
    Interceptor.attach(dlsymAddr, {
        onEnter: function(args) {
            this.args1 = args[1];
        },
        onLeave: function(retval) {
            var module = Process.findModuleByAddress(retval);
            if (module === null) return; 
            console.log(this.args1.readCString(), module.name, retval, retval.sub(module.base));
        }
    });
}
```





## linker

Linker是Android系统动态库so的加载器/链接器，通过android源码分析 init 和 init_array 是在 callConstructor 中被调用的



[frida hook init_array自吐新解](https://bbs.kanxue.com/thread-280135.htm)：

> 经过安卓源码比对，从Android 8 ~ 14，结构体中`init_array`的位置都很稳定，提取部分头文件信息在CModule中定义一个soinfo结构体，接着定义一个接受一个`soinfo`指针参数和一个`callback`函数的函数，输出`init_array`信息



```js
function hook_call_constructors() {
    // 初始化变量
    let get_soname = null;
    let call_constructors_addr = null;
    let hook_call_constructors_addr = true;
    // 根据进程的指针大小找到对应的linker模块
    let linker = null;
    if (Process.pointerSize == 4) {
        linker = Process.findModuleByName("linker");
    } else {
        linker = Process.findModuleByName("linker64");
    }
    // 枚举linker模块中的所有符号
    let symbols = linker.enumerateSymbols();
    for (let index = 0; index < symbols.length; index++) {
        let symbol = symbols[index];
        // 查找名为"__dl__ZN6soinfo17call_constructorsEv"的符号地址
        if (symbol.name == "__dl__ZN6soinfo17call_constructorsEv") {
            call_constructors_addr = symbol.address;
        // 查找名为"__dl__ZNK6soinfo10get_sonameEv"的符号地址，获取soname
        } else if (symbol.name == "__dl__ZNK6soinfo10get_sonameEv") {
            get_soname = new NativeFunction(symbol.address, "pointer", ["pointer"]);
        }
    }
    // 如果找到了所有需要的地址和函数
    if (hook_call_constructors_addr && call_constructors_addr && get_soname) {
        // 挂钩call_constructors函数
        Interceptor.attach(call_constructors_addr,{
            onEnter: function(args){
                // 从参数获取soinfo对象
                let soinfo = args[0];
                // 使用get_soname函数获取模块名称
                let soname = get_soname(soinfo).readCString();
                // 调用tell_init_info函数并传递一个回调，用于记录构造函数的调用信息
                tell_init_info(soinfo, new NativeCallback((count, init_array_ptr, init_func) => {
                    console.log(`[call_constructors] ${soname} count:${count}`);
                    console.log(`[call_constructors] init_array_ptr:${init_array_ptr}`);
                    console.log(`[call_constructors] init_func:${init_func} -> ${get_addr_info(init_func)}`);
                    // 遍历所有初始化函数，并打印它们的信息
                    for (let index = 0; index < count; index++) {
                        let init_array_func = init_array_ptr.add(Process.pointerSize * index).readPointer();
                        let func_info = get_addr_info(init_array_func);
                        console.log(`[call_constructors] init_array:${index} ${init_array_func} -> ${func_info}`);
                    }
                }, "void", ["int", "pointer", "pointer"]));
            }
        });
    }
}

```





# unidbg补环境方案

























# rpc方案

目前没有比较好的课程，只看到了珍惜大佬之前的架构图；以及xp模块；

其他的还没搜索到；

## rpc原理

frida 提供了一种跨平台的 rpc(就是Remote Procedure Call 远程过程调用) 机制，通过 frida rpc 可以在主机和目标设备之间进行通信，并在目标设备上执行代码，简单理解就是可以不需要分析某些复杂加密，通过传入参数获取返回值，进而来实现python或易语言来调用的一系列操作，多用于爬虫。



attach启动

```python
import frida, sys
jsCode = """ ...... """
script.exports.rpcfunc()

# 包名附加
process = frida.get_usb_device().attach('包名') # 获取USB设备并附加到应用


script = process.create_script(jsCode) # 创建并加载脚本
script.load()# 执行脚本
sys.stdin.read()# 保持脚本运行状态，防止它执行完毕后立即退出
```

如果是spawn启动

```python
pid = device.spawn(["包名"])    #以挂起方式创建进程
process = device.attach(pid)
```

切换其他端口

```python
manager = frida.get_device_manager()
process = manager.add_remote_device('192.168.1.22:6666').attach('包名')
```





## rpc使用案例









## rpc优化方案









# xposed技术





# 持久化hook技术



## magisk模块

[FridaManager](https://github.com/hanbinglengyue/FridaManager)

思路:基于magisk模块方案注入frida-gadget，实现加载和hook。
优点:无需重打包、灵活性较强
缺点:需要过root检测，magsik检测





## fridainject框架

思路:基于jshook封装好的fridainject框架实现hook



[me.jsonet.jshook](https://github.com/Xposed-Modules-Repo/me.jsonet.jshook)







# app脱壳

## 加壳原理



## dexdump





## fundex



# frida检测与对抗

小佳的课程讲的好

## 检测原因与对应so

1. 为啥app要做检测？
   - 防止爬虫
   - 保护代码被窃取（竞品公司）
   - 防止自动化（抢票，自动付款等等）

   
   
2. 什么时候出现frida检测？

   - 加固

     > 加固通常还会伴随其他检测；
     >
     > libDexHelper.so 等等

   - 广告sdk自带

     > libmsaoaidsec.so









## 检测原理

特征文件

crc校验









## 对抗分析

### 对抗思路

思路：

1. 找到检测的so文件
2. 找到hook时机
3. 找到so中检测点
4. hook掉关键函数





### so的加载流程

**加载so**->**链接so**->**初始化(init_proc)**->**数组初始化(init_array)**->**jni_onLoad**

[Android-so加载流程剖析](https://www.jianshu.com/p/9b7202786803)

先了解一下java如何导入的so以及加载流程

可以看一下经典的两张图

![1748445842552](./assets/1748445842552.png)

<img src="./assets/1748444422803.png" align="left" >

第一张图可以快速了解执行顺序，第二张图可以了解具体的调用顺序





















### libmsaoaidsec

一次性讲清楚这个so

这个so的背景：

这个so是多方联合搞出来的，网安机构+某大学+某实验室联合搞出来的

so的下载：常见app基本都有，github上也有

我们分析一下名字 lib msa oaid sec，msa是移动安全联盟(mobile secure )





这个so的检测内容包含：特征文件

检测机制：开线程

检测位置：init_array段的init_proc函数

如何对抗：杀检测入口函数 or 杀线程



最终脚本：

```js
function anti_libmsaoaidsec() {
    Interceptor.attach(Module.findExportByName(null, "android_dlopen_ext"), {
        onEnter: function (args) {
            var pathptr = args[0];
            if (pathptr !== undefined && pathptr != null) {
                this.fileName = ptr(pathptr).readCString();
                // console.log(`[+] dlopen onEnter ==> ${this.fileName}`); // 所有so的加载, 日志太多可注释
                // 针对 libmsaoaidsec.so 的hook
                if (this.fileName.indexOf("libmsaoaidsec.so") !== -1) { 
                    this.match_libmsaoaidsec = true; // 退出的时候用，就不用再次过滤了
                    console.log(`[+] dlopen onEnter ==> ${this.fileName}`); // 关键检测点，日志打开
                    // 检测点在init.proc，所以我们要hook linker的 call_constructors中
                    hook_linker64_call_constructors( );
                }
            }
        },
        onLeave: function (retval) {
            // 针对 libmsaoaidsec.so 的hook
            if (this.match_libmsaoaidsec) {
                // 确定是否在jni_onload进行的检测
                let JNI_OnLoad = Module.getExportByName(this.fileName, 'JNI_OnLoad');
                if (JNI_OnLoad){
                    console.warn(`[*] JNI_OnLoad address: ${JNI_OnLoad}`)
                    Interceptor.attach(JNI_OnLoad, {
                         onEnter: function (args) {
                             console.log(`[+] JNI_OnLoad onEnter!`); // 关键检测点，日志打开
                         }, onLeave: function (retval){
                             console.log(`[-] JNI_OnLoad onLeave!`); // 关键检测点，日志打开
                         }
                    });
                }
                console.log(`[-] dlopen onLeave ==> ${this.fileName}`);
            }
            // console.log(`[-] dlopen onLeave ==> ${this.fileName}`); // 所有so的加载完毕 
        }
    });
}


function hook_linker64_call_constructors() {
    // init_proc函数对应安卓源码就是linker64的call_constructors函数
    // 我们需要拿到call_constructors在linker64中的相对偏移，这个偏移地址与手机有关，手机执行下面命令可以拿到
    // readelf -sW /apex/com.android.runtime/bin/linker64 | grep call_constructors
    let address_call_constructors = Module.getBaseAddress('linker64').add(0x4a258); // 这个0x4a258要从上面的指令拿到offest
    let listener = Interceptor.attach(address_call_constructors, {
        onEnter: function (args) {
            console.log('[+] call_constructors onEnter');
            let secmodule = Process.findModuleByName("libmsaoaidsec.so");
            if (secmodule != null) {
                // 思路一：最直接的，外层检测函数，直接干掉就行，不同版本有区别
                // 常见的: 0x1B924、0x1A5B0、0x1BEC4；挨个试试就行
                replace(secmodule.base.add(0x1B924)); 
                // 思路二：定位杀进程函数然后置空（一般是一个，最好找全；）
                // replace(secmodule.base.add(0x1B8D4));
                // replace(secmodule.base.add(0x1B380));
                // replace(secmodule.base.add(0x19E0C));
                // replace(secmodule.base.add(0x1AB2C));
                // 思路三：找线程创建函数pthread_create，对检测函数置空（有时还没创建线程就闪退了；）

                // 思路四: 改汇编代码强行跳转或者直接nop函数 绕过app退出，但是不退出有可能卡死（和思路二差不多）
                
                // 这里是因为call_constructors中还有child的call_constructors, 我们只让最外层的执行就行了
                listener.detach(); 
            }
        }, onLeave: function (retval) {
            console.log("[-] call_constructors onLeave");
        }
    })
}

function replace(addr) { // 让函数啥也不干
    Interceptor.replace(addr, new NativeCallback(function () {
        console.warn(`[*] replace function, address: ${addr}!`)
    }, 'void', []));
}
```





分析过程（案例：豆瓣v7.100.0）

1. 先确认是否存在frida检测，而不是其他检测导致的

   >  不开frida啥事没有，开了之后，稍微用一下frida的api就闪退；

2. 定位具体检测的so文件

   > dlopen是负责加载so的

3. 确认检测时机

   > 看dlopen是否完全加载；
   >
   > 如果完全加载了，说明是开线程检测的；如果没有完全加载说明是在so中检测的，或者还没退出就开了线程检测到了；

   我们这里是没有正常dlopen结束；

   我们hook jni_onload

   

# frida源码













## frida-inject











## frida-gadget

这个so需要注入app中，所以需要重打包app；

优点：1）免root；2）稳定

不过我们一般需要改系统，让系统注入so，就不要重打包了。

> xposed是把代码注入了zygote。