

# 博主实盘信息接口

这个app提供模拟器用的so，所以模拟器也能用



![1750208696254](assets/1750208696254.png)

这个接口

![1750208736502](assets/1750208736502.png)

点击这个触发





其中主要参数位请求头sign，请求体data









## sign

### 定位

搜sign比较多，直接搜url，因为其他url相对出现sign几率比较小

![1750208831950](assets/1750208831950.png)



![1750208866775](assets/1750208866775.png)

发现用的还是比较多，不过都是什么 `secretNew` 和 `secretNew2`

点了第一个

![1750208976246](assets/1750208976246.png)



嗯，这里该有的都有，对比抓包一个不落

![1750209007333](assets/1750209007333.png)



四个参数都有，走的put方法

稍微分析一下，salt是str2，是一个随机小数（0-1）*10，也就是随机0-10整数

然后time是当前时间戳

sign走的是s方法，传入了 `time+salt+接口路径` 作为参数

![1750209177211](assets/1750209177211.png)



![1750209195052](assets/1750209195052.png)



最后定位到native函数，

下面有个加载so

![1750209212198](assets/1750209212198.png)

找一下具体名字

![1750209223232](assets/1750209223232.png)



所以是 `libns.so`

![1750209319013](assets/1750209319013.png)



静态注册的，找一下对应的函数



变量类型稍微调整一下

![1750209394806](assets/1750209394806.png)



然后倒着找

![1750209425568](assets/1750209425568.png)

3个return，主要是result和v14

![1750209446652](assets/1750209446652.png)

result啥也没做，我们看v14

![1750209471014](assets/1750209471014.png)

看着还是蛮像的，这里先是填充块

然后给了n100，再在代码块中设置了值

这里我们去hook一下java层参数，以及写一个主动调用



![1750209986475](assets/1750209986475.png)



稍微触发一下

```python
S.s is called: str=17502097628048getUserAccountInfoBySecretNew
S.s result=d3d53603fe524438ddc68e544e84cc970
```

`1750209762804` `8` `getUserAccountInfoBySecretNew` 三部分，我们主动调用一下

![1750210004653](assets/1750210004653.png)

好像有很多种，不过我们不关心，只要是明文相同，最后传哪一个都行的



让ai解析一下函数作用

![1750210211661](assets/1750210211661.png)



![1750210233511](assets/1750210233511.png)



所以关键函数就是这个三个方法了

输入参数是v5和s返回s_1，调用的是3个方法，看名字是什么 md5，异或之类的

这里我们先试试md5，发现java的字符串直接md5得不到正确的



这里我们关注一下v5和s

![1750210559202](assets/1750210559202.png)

首先v5是由java层明文转cstring得到

然后传入了p_cxor

![1750210595669](assets/1750210595669.png)

而这个s是由token得到的

![1750210618483](assets/1750210618483.png)

token是一个全局变量

![1750210650362](assets/1750210650362.png)



bss段就是为了存储一些全局变量用的，我们之后hook入参就行



接下来我们看这三个函数

先看md5



![1750211340263](assets/1750211340263.png)



![1750211353640](assets/1750211353640.png)





s_2来源比较多，引诱由free，所以我们关注s_3就行

![1750211438191](assets/1750211438191.png)

看样子主要是和s_1和v11有关

s_1又和s_有关

![1750211474396](assets/1750211474396.png)





v11与v14有关

![1750211507917](assets/1750211507917.png)

这里往上看发现了md5看样子主要与`s_`有关，`s_` 负责接收格式化字符串

然后由v16和v17传入



![1750211793294](assets/1750211793294.png)



我们hook一下update的传入数据，主要是第二个

![1750212186850](assets/1750212186850.png)

前面加了点盐

`2b641e2dec449b95019792f537557bb817502097628048getUserAccountInfoBySecretNew` 拿去测试一下

![1750212356136](assets/1750212356136.png)

对比发现前面加了个d，可能是用于做标识符什么的，比如告诉服务器我这用了什么算法

我们再换一个

![1750212411731](assets/1750212411731.png)

发现前面部分没变

同样的，对比其他算法，`axor`前面开头b，`chainXor` 开头固定C

![1750213815334](assets/1750213815334.png)

这里的n100就是第一个字符，这里设置了第一个字符的ascii，100就是d

到这里我们就可以直接拿md5进行发包了

对于剩下的算法我们可以不逆向，因为是异或，ai对这种比较熟，我们直接让ai写代码





### 算法还原

1. md5

   ![1750213260801](assets/1750213260801.png)

2. axor

   ![1750213252493](assets/1750213252493.png)

3. cxor

   这里测试了一下，发现不走chainXor

   ![1750214174533](assets/1750214174533.png)

   而是下面的cxor

   ![1750214378628](assets/1750214378628.png)





发个全部版截图

![1750214394333](assets/1750214394333.png)

与内存中计算的对比一下

![1750214469147](assets/1750214469147.png)



没啥问题，都算好了才发现有一个算法只有大小写区别；当然chainXor也有，不过爬虫尽可能别用这种，否则可能会被标记









## data

我们前面的地方是猜测的一个位置，只是最后调用了s而已；

所以我们需要跟栈找到正确位置，在前面发请求那里加个打印调用栈

![1750217657920](assets/1750217657920.png)

最后定位到

![1750217682423](assets/1750217682423.png)

这里一直跟`semdRequest`

![1750218283934](assets/1750218283934.png)

找到了这里有一个success

![1750218334336](assets/1750218334336.png)

发现实际上走的是最后的success

![1750218363971](assets/1750218363971.png)

接口，回去找 `requestCallback -> this.mRequestCallback`

![1750218420547](assets/1750218420547.png)

这里找到赋值位置，所以时前面的build塞进去的requestCallback

![1750218470762](assets/1750218470762.png)

hook一下就行







下面这个方法有点问题

由于是响应搜 JSONobject相关的

![1750228301054](assets/1750228301054.png)



![1750228680921](assets/1750228680921.png)

hook验证走了这里，然后i3是code，正常返回的话是0

所以走 `onDataSuccess`

然后继续![1750229165562](assets/1750229165562.png)

是个接口，我们去找调用这个的实例，hook打印一下

![1750229228944](assets/1750229228944.png)

拿到类名，去搜一下

发现没搜到，可能反编译有点问题

最后实际上在 `com.fivefivelike.mybaselibrary.base.BaseDataBindFragment`，这可能安卓activity进行绑定有关

![1750228657080](assets/1750228657080.png)



点进去

![1750228633505](assets/1750228633505.png)

找到这里用了





看so层

![1750230753198](assets/1750230753198.png)

点进去看看

![1750230797766](assets/1750230797766.png)

先是b64解码然后再进入 `qqqpqp` 中进行解密，解好了给s_2最后返回

我们先看看key和iv

直接hook函数拿到值

![1750231170123](assets/1750231170123.png)

key和iv都是一样的

进到函数拿的都是全局变量

![1750231195366](assets/1750231195366.png)

`e6 5e a7 02 3d 74 8f f5 22 56 6e 32 ca df ae 88`

我们去测试一下

![1750231600405](assets/1750231600405.png)

没啥问题

接下来写一下python

![1750232265264](assets/1750232265264.png)

搞定