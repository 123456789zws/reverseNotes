// lib: , url: package:billiards/data/msg/battleUser.dart

// class id: 1048730, size: 0x8
class :: {

  static _ _$BattleUserToJson(/* No info */) {
    // ** addr: 0x6e0570, size: 0xd8
    // 0x6e0570: EnterFrame
    //     0x6e0570: stp             fp, lr, [SP, #-0x10]!
    //     0x6e0574: mov             fp, SP
    // 0x6e0578: AllocStack(0x10)
    //     0x6e0578: sub             SP, SP, #0x10
    // 0x6e057c: CheckStackOverflow
    //     0x6e057c: ldr             x16, [THR, #0x38]  ; THR::stack_limit
    //     0x6e0580: cmp             SP, x16
    //     0x6e0584: b.ls            #0x6e0640
    // 0x6e0588: r1 = Null
    //     0x6e0588: mov             x1, NULL
    // 0x6e058c: r2 = 24
    //     0x6e058c: movz            x2, #0x18
    // 0x6e0590: r0 = AllocateArray()
    //     0x6e0590: bl              #0xc5eccc  ; AllocateArrayStub
    // 0x6e0594: r17 = "headImage"
    //     0x6e0594: add             x17, PP, #0xe, lsl #12  ; [pp+0xef98] "headImage"
    //     0x6e0598: ldr             x17, [x17, #0xf98]
    // 0x6e059c: StoreField: r0->field_f = r17
    //     0x6e059c: stur            w17, [x0, #0xf]
    // 0x6e05a0: ldr             x1, [fp, #0x10]
    // 0x6e05a4: LoadField: r2 = r1->field_7
    //     0x6e05a4: ldur            w2, [x1, #7]
    // 0x6e05a8: DecompressPointer r2
    //     0x6e05a8: add             x2, x2, HEAP, lsl #32
    // 0x6e05ac: StoreField: r0->field_13 = r2
    //     0x6e05ac: stur            w2, [x0, #0x13]
    // 0x6e05b0: r17 = "userName"
    //     0x6e05b0: add             x17, PP, #0xe, lsl #12  ; [pp+0xef88] "userName"
    //     0x6e05b4: ldr             x17, [x17, #0xf88]
    // 0x6e05b8: ArrayStore: r0[0] = r17  ; List_4
    //     0x6e05b8: stur            w17, [x0, #0x17]
    // 0x6e05bc: LoadField: r2 = r1->field_b
    //     0x6e05bc: ldur            w2, [x1, #0xb]
    // 0x6e05c0: DecompressPointer r2
    //     0x6e05c0: add             x2, x2, HEAP, lsl #32
    // 0x6e05c4: StoreField: r0->field_1b = r2
    //     0x6e05c4: stur            w2, [x0, #0x1b]
    // 0x6e05c8: r17 = "bigLevelCode"
    //     0x6e05c8: add             x17, PP, #0x16, lsl #12  ; [pp+0x16468] "bigLevelCode"
    //     0x6e05cc: ldr             x17, [x17, #0x468]
    // 0x6e05d0: StoreField: r0->field_1f = r17
    //     0x6e05d0: stur            w17, [x0, #0x1f]
    // 0x6e05d4: LoadField: r2 = r1->field_f
    //     0x6e05d4: ldur            w2, [x1, #0xf]
    // 0x6e05d8: DecompressPointer r2
    //     0x6e05d8: add             x2, x2, HEAP, lsl #32
    // 0x6e05dc: StoreField: r0->field_23 = r2
    //     0x6e05dc: stur            w2, [x0, #0x23]
    // 0x6e05e0: r17 = "battleScore"
    //     0x6e05e0: add             x17, PP, #0x16, lsl #12  ; [pp+0x16480] "battleScore"
    //     0x6e05e4: ldr             x17, [x17, #0x480]
    // 0x6e05e8: StoreField: r0->field_27 = r17
    //     0x6e05e8: stur            w17, [x0, #0x27]
    // 0x6e05ec: LoadField: r2 = r1->field_13
    //     0x6e05ec: ldur            w2, [x1, #0x13]
    // 0x6e05f0: DecompressPointer r2
    //     0x6e05f0: add             x2, x2, HEAP, lsl #32
    // 0x6e05f4: StoreField: r0->field_2b = r2
    //     0x6e05f4: stur            w2, [x0, #0x2b]
    // 0x6e05f8: r17 = "userId"
    //     0x6e05f8: add             x17, PP, #0x12, lsl #12  ; [pp+0x12358] "userId"
    //     0x6e05fc: ldr             x17, [x17, #0x358]
    // 0x6e0600: StoreField: r0->field_2f = r17
    //     0x6e0600: stur            w17, [x0, #0x2f]
    // 0x6e0604: ArrayLoad: r2 = r1[0]  ; List_4
    //     0x6e0604: ldur            w2, [x1, #0x17]
    // 0x6e0608: DecompressPointer r2
    //     0x6e0608: add             x2, x2, HEAP, lsl #32
    // 0x6e060c: StoreField: r0->field_33 = r2
    //     0x6e060c: stur            w2, [x0, #0x33]
    // 0x6e0610: r17 = "levelName"
    //     0x6e0610: add             x17, PP, #0x16, lsl #12  ; [pp+0x164a8] "levelName"
    //     0x6e0614: ldr             x17, [x17, #0x4a8]
    // 0x6e0618: StoreField: r0->field_37 = r17
    //     0x6e0618: stur            w17, [x0, #0x37]
    // 0x6e061c: LoadField: r2 = r1->field_1b
    //     0x6e061c: ldur            w2, [x1, #0x1b]
    // 0x6e0620: DecompressPointer r2
    //     0x6e0620: add             x2, x2, HEAP, lsl #32
    // 0x6e0624: StoreField: r0->field_3b = r2
    //     0x6e0624: stur            w2, [x0, #0x3b]
    // 0x6e0628: r16 = <String, dynamic>
    //     0x6e0628: ldr             x16, [PP, #0xd78]  ; [pp+0xd78] TypeArguments: <String, dynamic>
    // 0x6e062c: stp             x0, x16, [SP]
    // 0x6e0630: r0 = Map._fromLiteral()
    //     0x6e0630: bl              #0x4da070  ; [dart:core] Map::Map._fromLiteral
    // 0x6e0634: LeaveFrame
    //     0x6e0634: mov             SP, fp
    //     0x6e0638: ldp             fp, lr, [SP], #0x10
    // 0x6e063c: ret
    //     0x6e063c: ret             
    // 0x6e0640: r0 = StackOverflowSharedWithoutFPURegs()
    //     0x6e0640: bl              #0xc5ee88  ; StackOverflowSharedWithoutFPURegsStub
    // 0x6e0644: b               #0x6e0588
  }
  static _ _$BattleUserFromJson(/* No info */) {
    // ** addr: 0x6e0be0, size: 0x33c
    // 0x6e0be0: EnterFrame
    //     0x6e0be0: stp             fp, lr, [SP, #-0x10]!
    //     0x6e0be4: mov             fp, SP
    // 0x6e0be8: AllocStack(0x20)
    //     0x6e0be8: sub             SP, SP, #0x20
    // 0x6e0bec: CheckStackOverflow
    //     0x6e0bec: ldr             x16, [THR, #0x38]  ; THR::stack_limit
    //     0x6e0bf0: cmp             SP, x16
    //     0x6e0bf4: b.ls            #0x6e0f14
    // 0x6e0bf8: ldr             x1, [fp, #0x10]
    // 0x6e0bfc: r0 = LoadClassIdInstr(r1)
    //     0x6e0bfc: ldur            x0, [x1, #-1]
    //     0x6e0c00: ubfx            x0, x0, #0xc, #0x14
    // 0x6e0c04: r16 = "headImage"
    //     0x6e0c04: add             x16, PP, #0xe, lsl #12  ; [pp+0xef98] "headImage"
    //     0x6e0c08: ldr             x16, [x16, #0xf98]
    // 0x6e0c0c: stp             x16, x1, [SP]
    // 0x6e0c10: r0 = GDT[cid_x0 + -0xfb]()
    //     0x6e0c10: sub             lr, x0, #0xfb
    //     0x6e0c14: ldr             lr, [x21, lr, lsl #3]
    //     0x6e0c18: blr             lr
    // 0x6e0c1c: mov             x3, x0
    // 0x6e0c20: r2 = Null
    //     0x6e0c20: mov             x2, NULL
    // 0x6e0c24: r1 = Null
    //     0x6e0c24: mov             x1, NULL
    // 0x6e0c28: stur            x3, [fp, #-8]
    // 0x6e0c2c: r4 = 59
    //     0x6e0c2c: movz            x4, #0x3b
    // 0x6e0c30: branchIfSmi(r0, 0x6e0c3c)
    //     0x6e0c30: tbz             w0, #0, #0x6e0c3c
    // 0x6e0c34: r4 = LoadClassIdInstr(r0)
    //     0x6e0c34: ldur            x4, [x0, #-1]
    //     0x6e0c38: ubfx            x4, x4, #0xc, #0x14
    // 0x6e0c3c: sub             x4, x4, #0x5d
    // 0x6e0c40: cmp             x4, #3
    // 0x6e0c44: b.ls            #0x6e0c58
    // 0x6e0c48: r8 = String?
    //     0x6e0c48: ldr             x8, [PP, #0xc08]  ; [pp+0xc08] Type: String?
    // 0x6e0c4c: r3 = Null
    //     0x6e0c4c: add             x3, PP, #0x16, lsl #12  ; [pp+0x16448] Null
    //     0x6e0c50: ldr             x3, [x3, #0x448]
    // 0x6e0c54: r0 = String?()
    //     0x6e0c54: bl              #0x4c4d70  ; IsType_String?_Stub
    // 0x6e0c58: r0 = BattleUser()
    //     0x6e0c58: bl              #0x6e0f1c  ; AllocateBattleUserStub -> BattleUser (size=0x20)
    // 0x6e0c5c: mov             x1, x0
    // 0x6e0c60: ldur            x0, [fp, #-8]
    // 0x6e0c64: stur            x1, [fp, #-0x10]
    // 0x6e0c68: StoreField: r1->field_7 = r0
    //     0x6e0c68: stur            w0, [x1, #7]
    // 0x6e0c6c: ldr             x2, [fp, #0x10]
    // 0x6e0c70: r0 = LoadClassIdInstr(r2)
    //     0x6e0c70: ldur            x0, [x2, #-1]
    //     0x6e0c74: ubfx            x0, x0, #0xc, #0x14
    // 0x6e0c78: r16 = "userName"
    //     0x6e0c78: add             x16, PP, #0xe, lsl #12  ; [pp+0xef88] "userName"
    //     0x6e0c7c: ldr             x16, [x16, #0xf88]
    // 0x6e0c80: stp             x16, x2, [SP]
    // 0x6e0c84: r0 = GDT[cid_x0 + -0xfb]()
    //     0x6e0c84: sub             lr, x0, #0xfb
    //     0x6e0c88: ldr             lr, [x21, lr, lsl #3]
    //     0x6e0c8c: blr             lr
    // 0x6e0c90: mov             x3, x0
    // 0x6e0c94: r2 = Null
    //     0x6e0c94: mov             x2, NULL
    // 0x6e0c98: r1 = Null
    //     0x6e0c98: mov             x1, NULL
    // 0x6e0c9c: stur            x3, [fp, #-8]
    // 0x6e0ca0: r4 = 59
    //     0x6e0ca0: movz            x4, #0x3b
    // 0x6e0ca4: branchIfSmi(r0, 0x6e0cb0)
    //     0x6e0ca4: tbz             w0, #0, #0x6e0cb0
    // 0x6e0ca8: r4 = LoadClassIdInstr(r0)
    //     0x6e0ca8: ldur            x4, [x0, #-1]
    //     0x6e0cac: ubfx            x4, x4, #0xc, #0x14
    // 0x6e0cb0: sub             x4, x4, #0x5d
    // 0x6e0cb4: cmp             x4, #3
    // 0x6e0cb8: b.ls            #0x6e0ccc
    // 0x6e0cbc: r8 = String?
    //     0x6e0cbc: ldr             x8, [PP, #0xc08]  ; [pp+0xc08] Type: String?
    // 0x6e0cc0: r3 = Null
    //     0x6e0cc0: add             x3, PP, #0x16, lsl #12  ; [pp+0x16458] Null
    //     0x6e0cc4: ldr             x3, [x3, #0x458]
    // 0x6e0cc8: r0 = String?()
    //     0x6e0cc8: bl              #0x4c4d70  ; IsType_String?_Stub
    // 0x6e0ccc: ldur            x0, [fp, #-8]
    // 0x6e0cd0: ldur            x1, [fp, #-0x10]
    // 0x6e0cd4: StoreField: r1->field_b = r0
    //     0x6e0cd4: stur            w0, [x1, #0xb]
    //     0x6e0cd8: ldurb           w16, [x1, #-1]
    //     0x6e0cdc: ldurb           w17, [x0, #-1]
    //     0x6e0ce0: and             x16, x17, x16, lsr #2
    //     0x6e0ce4: tst             x16, HEAP, lsr #32
    //     0x6e0ce8: b.eq            #0x6e0cf0
    //     0x6e0cec: bl              #0xc5d6fc  ; WriteBarrierWrappersStub
    // 0x6e0cf0: ldr             x2, [fp, #0x10]
    // 0x6e0cf4: r0 = LoadClassIdInstr(r2)
    //     0x6e0cf4: ldur            x0, [x2, #-1]
    //     0x6e0cf8: ubfx            x0, x0, #0xc, #0x14
    // 0x6e0cfc: r16 = "bigLevelCode"
    //     0x6e0cfc: add             x16, PP, #0x16, lsl #12  ; [pp+0x16468] "bigLevelCode"
    //     0x6e0d00: ldr             x16, [x16, #0x468]
    // 0x6e0d04: stp             x16, x2, [SP]
    // 0x6e0d08: r0 = GDT[cid_x0 + -0xfb]()
    //     0x6e0d08: sub             lr, x0, #0xfb
    //     0x6e0d0c: ldr             lr, [x21, lr, lsl #3]
    //     0x6e0d10: blr             lr
    // 0x6e0d14: mov             x3, x0
    // 0x6e0d18: r2 = Null
    //     0x6e0d18: mov             x2, NULL
    // 0x6e0d1c: r1 = Null
    //     0x6e0d1c: mov             x1, NULL
    // 0x6e0d20: stur            x3, [fp, #-8]
    // 0x6e0d24: branchIfSmi(r0, 0x6e0d4c)
    //     0x6e0d24: tbz             w0, #0, #0x6e0d4c
    // 0x6e0d28: r4 = LoadClassIdInstr(r0)
    //     0x6e0d28: ldur            x4, [x0, #-1]
    //     0x6e0d2c: ubfx            x4, x4, #0xc, #0x14
    // 0x6e0d30: sub             x4, x4, #0x3b
    // 0x6e0d34: cmp             x4, #1
    // 0x6e0d38: b.ls            #0x6e0d4c
    // 0x6e0d3c: r8 = int?
    //     0x6e0d3c: ldr             x8, [PP, #0x4c60]  ; [pp+0x4c60] Type: int?
    // 0x6e0d40: r3 = Null
    //     0x6e0d40: add             x3, PP, #0x16, lsl #12  ; [pp+0x16470] Null
    //     0x6e0d44: ldr             x3, [x3, #0x470]
    // 0x6e0d48: r0 = int?()
    //     0x6e0d48: bl              #0xc64ac0  ; IsType_int?_Stub
    // 0x6e0d4c: ldur            x0, [fp, #-8]
    // 0x6e0d50: ldur            x1, [fp, #-0x10]
    // 0x6e0d54: StoreField: r1->field_f = r0
    //     0x6e0d54: stur            w0, [x1, #0xf]
    //     0x6e0d58: tbz             w0, #0, #0x6e0d74
    //     0x6e0d5c: ldurb           w16, [x1, #-1]
    //     0x6e0d60: ldurb           w17, [x0, #-1]
    //     0x6e0d64: and             x16, x17, x16, lsr #2
    //     0x6e0d68: tst             x16, HEAP, lsr #32
    //     0x6e0d6c: b.eq            #0x6e0d74
    //     0x6e0d70: bl              #0xc5d6fc  ; WriteBarrierWrappersStub
    // 0x6e0d74: ldr             x2, [fp, #0x10]
    // 0x6e0d78: r0 = LoadClassIdInstr(r2)
    //     0x6e0d78: ldur            x0, [x2, #-1]
    //     0x6e0d7c: ubfx            x0, x0, #0xc, #0x14
    // 0x6e0d80: r16 = "battleScore"
    //     0x6e0d80: add             x16, PP, #0x16, lsl #12  ; [pp+0x16480] "battleScore"
    //     0x6e0d84: ldr             x16, [x16, #0x480]
    // 0x6e0d88: stp             x16, x2, [SP]
    // 0x6e0d8c: r0 = GDT[cid_x0 + -0xfb]()
    //     0x6e0d8c: sub             lr, x0, #0xfb
    //     0x6e0d90: ldr             lr, [x21, lr, lsl #3]
    //     0x6e0d94: blr             lr
    // 0x6e0d98: mov             x3, x0
    // 0x6e0d9c: r2 = Null
    //     0x6e0d9c: mov             x2, NULL
    // 0x6e0da0: r1 = Null
    //     0x6e0da0: mov             x1, NULL
    // 0x6e0da4: stur            x3, [fp, #-8]
    // 0x6e0da8: branchIfSmi(r0, 0x6e0dd0)
    //     0x6e0da8: tbz             w0, #0, #0x6e0dd0
    // 0x6e0dac: r4 = LoadClassIdInstr(r0)
    //     0x6e0dac: ldur            x4, [x0, #-1]
    //     0x6e0db0: ubfx            x4, x4, #0xc, #0x14
    // 0x6e0db4: sub             x4, x4, #0x3b
    // 0x6e0db8: cmp             x4, #1
    // 0x6e0dbc: b.ls            #0x6e0dd0
    // 0x6e0dc0: r8 = int?
    //     0x6e0dc0: ldr             x8, [PP, #0x4c60]  ; [pp+0x4c60] Type: int?
    // 0x6e0dc4: r3 = Null
    //     0x6e0dc4: add             x3, PP, #0x16, lsl #12  ; [pp+0x16488] Null
    //     0x6e0dc8: ldr             x3, [x3, #0x488]
    // 0x6e0dcc: r0 = int?()
    //     0x6e0dcc: bl              #0xc64ac0  ; IsType_int?_Stub
    // 0x6e0dd0: ldur            x0, [fp, #-8]
    // 0x6e0dd4: ldur            x1, [fp, #-0x10]
    // 0x6e0dd8: StoreField: r1->field_13 = r0
    //     0x6e0dd8: stur            w0, [x1, #0x13]
    //     0x6e0ddc: tbz             w0, #0, #0x6e0df8
    //     0x6e0de0: ldurb           w16, [x1, #-1]
    //     0x6e0de4: ldurb           w17, [x0, #-1]
    //     0x6e0de8: and             x16, x17, x16, lsr #2
    //     0x6e0dec: tst             x16, HEAP, lsr #32
    //     0x6e0df0: b.eq            #0x6e0df8
    //     0x6e0df4: bl              #0xc5d6fc  ; WriteBarrierWrappersStub
    // 0x6e0df8: ldr             x2, [fp, #0x10]
    // 0x6e0dfc: r0 = LoadClassIdInstr(r2)
    //     0x6e0dfc: ldur            x0, [x2, #-1]
    //     0x6e0e00: ubfx            x0, x0, #0xc, #0x14
    // 0x6e0e04: r16 = "userId"
    //     0x6e0e04: add             x16, PP, #0x12, lsl #12  ; [pp+0x12358] "userId"
    //     0x6e0e08: ldr             x16, [x16, #0x358]
    // 0x6e0e0c: stp             x16, x2, [SP]
    // 0x6e0e10: r0 = GDT[cid_x0 + -0xfb]()
    //     0x6e0e10: sub             lr, x0, #0xfb
    //     0x6e0e14: ldr             lr, [x21, lr, lsl #3]
    //     0x6e0e18: blr             lr
    // 0x6e0e1c: mov             x3, x0
    // 0x6e0e20: r2 = Null
    //     0x6e0e20: mov             x2, NULL
    // 0x6e0e24: r1 = Null
    //     0x6e0e24: mov             x1, NULL
    // 0x6e0e28: stur            x3, [fp, #-8]
    // 0x6e0e2c: branchIfSmi(r0, 0x6e0e54)
    //     0x6e0e2c: tbz             w0, #0, #0x6e0e54
    // 0x6e0e30: r4 = LoadClassIdInstr(r0)
    //     0x6e0e30: ldur            x4, [x0, #-1]
    //     0x6e0e34: ubfx            x4, x4, #0xc, #0x14
    // 0x6e0e38: sub             x4, x4, #0x3b
    // 0x6e0e3c: cmp             x4, #1
    // 0x6e0e40: b.ls            #0x6e0e54
    // 0x6e0e44: r8 = int?
    //     0x6e0e44: ldr             x8, [PP, #0x4c60]  ; [pp+0x4c60] Type: int?
    // 0x6e0e48: r3 = Null
    //     0x6e0e48: add             x3, PP, #0x16, lsl #12  ; [pp+0x16498] Null
    //     0x6e0e4c: ldr             x3, [x3, #0x498]
    // 0x6e0e50: r0 = int?()
    //     0x6e0e50: bl              #0xc64ac0  ; IsType_int?_Stub
    // 0x6e0e54: ldur            x0, [fp, #-8]
    // 0x6e0e58: ldur            x1, [fp, #-0x10]
    // 0x6e0e5c: ArrayStore: r1[0] = r0  ; List_4
    //     0x6e0e5c: stur            w0, [x1, #0x17]
    //     0x6e0e60: tbz             w0, #0, #0x6e0e7c
    //     0x6e0e64: ldurb           w16, [x1, #-1]
    //     0x6e0e68: ldurb           w17, [x0, #-1]
    //     0x6e0e6c: and             x16, x17, x16, lsr #2
    //     0x6e0e70: tst             x16, HEAP, lsr #32
    //     0x6e0e74: b.eq            #0x6e0e7c
    //     0x6e0e78: bl              #0xc5d6fc  ; WriteBarrierWrappersStub
    // 0x6e0e7c: ldr             x0, [fp, #0x10]
    // 0x6e0e80: r2 = LoadClassIdInstr(r0)
    //     0x6e0e80: ldur            x2, [x0, #-1]
    //     0x6e0e84: ubfx            x2, x2, #0xc, #0x14
    // 0x6e0e88: r16 = "levelName"
    //     0x6e0e88: add             x16, PP, #0x16, lsl #12  ; [pp+0x164a8] "levelName"
    //     0x6e0e8c: ldr             x16, [x16, #0x4a8]
    // 0x6e0e90: stp             x16, x0, [SP]
    // 0x6e0e94: mov             x0, x2
    // 0x6e0e98: r0 = GDT[cid_x0 + -0xfb]()
    //     0x6e0e98: sub             lr, x0, #0xfb
    //     0x6e0e9c: ldr             lr, [x21, lr, lsl #3]
    //     0x6e0ea0: blr             lr
    // 0x6e0ea4: mov             x3, x0
    // 0x6e0ea8: r2 = Null
    //     0x6e0ea8: mov             x2, NULL
    // 0x6e0eac: r1 = Null
    //     0x6e0eac: mov             x1, NULL
    // 0x6e0eb0: stur            x3, [fp, #-8]
    // 0x6e0eb4: r4 = 59
    //     0x6e0eb4: movz            x4, #0x3b
    // 0x6e0eb8: branchIfSmi(r0, 0x6e0ec4)
    //     0x6e0eb8: tbz             w0, #0, #0x6e0ec4
    // 0x6e0ebc: r4 = LoadClassIdInstr(r0)
    //     0x6e0ebc: ldur            x4, [x0, #-1]
    //     0x6e0ec0: ubfx            x4, x4, #0xc, #0x14
    // 0x6e0ec4: sub             x4, x4, #0x5d
    // 0x6e0ec8: cmp             x4, #3
    // 0x6e0ecc: b.ls            #0x6e0ee0
    // 0x6e0ed0: r8 = String?
    //     0x6e0ed0: ldr             x8, [PP, #0xc08]  ; [pp+0xc08] Type: String?
    // 0x6e0ed4: r3 = Null
    //     0x6e0ed4: add             x3, PP, #0x16, lsl #12  ; [pp+0x164b0] Null
    //     0x6e0ed8: ldr             x3, [x3, #0x4b0]
    // 0x6e0edc: r0 = String?()
    //     0x6e0edc: bl              #0x4c4d70  ; IsType_String?_Stub
    // 0x6e0ee0: ldur            x0, [fp, #-8]
    // 0x6e0ee4: ldur            x1, [fp, #-0x10]
    // 0x6e0ee8: StoreField: r1->field_1b = r0
    //     0x6e0ee8: stur            w0, [x1, #0x1b]
    //     0x6e0eec: ldurb           w16, [x1, #-1]
    //     0x6e0ef0: ldurb           w17, [x0, #-1]
    //     0x6e0ef4: and             x16, x17, x16, lsr #2
    //     0x6e0ef8: tst             x16, HEAP, lsr #32
    //     0x6e0efc: b.eq            #0x6e0f04
    //     0x6e0f00: bl              #0xc5d6fc  ; WriteBarrierWrappersStub
    // 0x6e0f04: mov             x0, x1
    // 0x6e0f08: LeaveFrame
    //     0x6e0f08: mov             SP, fp
    //     0x6e0f0c: ldp             fp, lr, [SP], #0x10
    // 0x6e0f10: ret
    //     0x6e0f10: ret             
    // 0x6e0f14: r0 = StackOverflowSharedWithoutFPURegs()
    //     0x6e0f14: bl              #0xc5ee88  ; StackOverflowSharedWithoutFPURegsStub
    // 0x6e0f18: b               #0x6e0bf8
  }
}

// class id: 4932, size: 0x20, field offset: 0x8
class BattleUser extends Object {

  Map<String, dynamic> toJson(BattleUser) {
    // ** addr: 0x6e0538, size: 0x50
    // 0x6e0538: EnterFrame
    //     0x6e0538: stp             fp, lr, [SP, #-0x10]!
    //     0x6e053c: mov             fp, SP
    // 0x6e0540: AllocStack(0x8)
    //     0x6e0540: sub             SP, SP, #8
    // 0x6e0544: CheckStackOverflow
    //     0x6e0544: ldr             x16, [THR, #0x38]  ; THR::stack_limit
    //     0x6e0548: cmp             SP, x16
    //     0x6e054c: b.ls            #0x6e0568
    // 0x6e0550: ldr             x16, [fp, #0x10]
    // 0x6e0554: str             x16, [SP]
    // 0x6e0558: r0 = _$BattleUserToJson()
    //     0x6e0558: bl              #0x6e0570  ; [package:billiards/data/msg/battleUser.dart] ::_$BattleUserToJson
    // 0x6e055c: LeaveFrame
    //     0x6e055c: mov             SP, fp
    //     0x6e0560: ldp             fp, lr, [SP], #0x10
    // 0x6e0564: ret
    //     0x6e0564: ret             
    // 0x6e0568: r0 = StackOverflowSharedWithoutFPURegs()
    //     0x6e0568: bl              #0xc5ee88  ; StackOverflowSharedWithoutFPURegsStub
    // 0x6e056c: b               #0x6e0550
  }
}
